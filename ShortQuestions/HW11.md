# HW11 Spring Security

## 1. List all of the annotations you learned from this class session.

1. @ComponentScan(basePackages = { "com.chuwa.training" }):

- Scans the specified base package for Spring components (like @Controller, @Service, @Repository, etc.).

2. @PutMapping(value = "/{id}", produces = "application/xml", consumes = "application/json"):

- Handles HTTP PUT requests.
- The value attribute defines the URL pattern.
- The produces attribute specifies the media type (e.g., XML) that the method will produce in the response.
- The consumes attribute specifies the media type (e.g., JSON) that the method expects in the request body.

3. @RestController:

- A convenience annotation that combines @Controller and @ResponseBody.
- Used to simplify the creation of RESTful web services by returning the response directly as an object in the form of JSON or XML.

## 2. Explain TLS, PKI, certificate, public key, private key, and signature.

- **TLS (Transport Layer Security)**: A protocol that ensures secure communication over a network by encrypting data between a client and server.

- **PKI (Public Key Infrastructure)**: A framework that uses cryptographic methods, such as certificates, to secure communications and verify identities over a network, leveraging a system of trusted Certificate Authorities (CAs).

- **Certificate**: A digital document that uses a public key and verifies the identity of a party (e.g., a server). It's issued by a trusted Certificate Authority (CA).

- **Public Key**: A cryptographic key used to encrypt data or verify a digital signature. It is shared publicly and is part of a public-private key pair.

- **Private Key**: A cryptographic key that must be kept secret. It is used to decrypt data encrypted by the corresponding public key or to create a digital signature.

- **Signature**: A cryptographic method to verify data integrity and authenticity, created using a private key and verified with the corresponding public key.

## 3. Spring security based application

refer to the Coding/src part.

## 4. list all http status codes that related to authentication and authorization failures.

- **401 Unauthorized**: The request requires authentication. The client failed to provide valid credentials, or the credentials are missing or invalid.
- **403 Forbidden**: The client is authenticated but does not have permission to access the requested resource. This can occur when the clientâ€™s credentials are valid but they lack sufficient privileges.

- **407 Proxy Authentication Required**: The client must authenticate with a proxy before it can send the request to the destination server.

- **419 Authentication Timeout**: Although not an official status code, some systems use this to indicate that authentication has timed out, requiring the user to log in again.

- **511 Network Authentication Required**: The client must authenticate to gain network access, often seen in captive portals that require the user to log in or accept terms before connecting to the network.

## 5. Compare authentication and authorization? Name and explain important components in Spring security that undertake authentication and authorization

### Authentication vs Authorization

- **Authentication**: Verifies identity (e.g., login with username/password). Answers "Who are you?"
- **Authorization**: Determines what an authenticated user can do (e.g., access control). Answers "What can you do?"

### Key Spring Security Components

- **AuthenticationManager**: Handles authentication by delegating to `AuthenticationProvider`.
- **AuthenticationProvider**: Verifies credentials against data (e.g., DB or LDAP).
- **UserDetailsService**: Loads user data for authentication.
- **SecurityContext**: Stores authenticated user info (`Authentication` object).
- **GrantedAuthority**: Represents user roles/permissions.
- **AccessDecisionManager**: Decides if a user has permission to access resources.
- **Filters (e.g., UsernamePasswordAuthenticationFilter)**: Intercepts HTTP requests for authentication.
- **Role Hierarchy**: Manages roles with inherited permissions.
- **PreAuthorize/PostAuthorize**: Method-level security with authorization annotations.
- **OAuth2/JWT Support**: Provides OAuth2 and JWT support for API security.

## 6. Explain HTTP Session?

An HTTP session is a mechanism used by servers to maintain state across multiple requests from the same client in a stateless HTTP protocol. A session is created when a user interacts with a web application (e.g., logging in), and the server assigns a unique session ID, typically stored in a cookie. The session allows the server to store user-specific data, such as login status or preferences, enabling personalized interactions across multiple requests. Sessions typically expire after inactivity or when the user logs out.

## 7. Explain Cookie?

A cookie is a small piece of data stored on the user's browser by a website. It is used to remember information about the user between requests, such as session IDs, user preferences, or tracking data. Cookies can be persistent (stored for a set duration) or session-based (deleted after the browser is closed). They are often used for user authentication, personalization, and tracking user behavior.

## 8. Compare Session and Cookie?

### Session vs Cookie

- **Session**:

  - Stores user data on the server (e.g., login info, preferences).
  - Identified by a session ID, often stored in a cookie.
  - Data is temporary and typically expires after logout or inactivity.

- **Cookie**:
  - Stores data on the client (browser) as small text files.
  - Can be used for tracking, session identification, or storing preferences.
  - Can be persistent (with expiration dates) or session-based (deleted after browser close).

**Key Difference**: Sessions store data server-side, while cookies store data client-side.

## 9. Websites Supporting Google SSO and How SSO Works

### **Trello**:

Trello allows users to log in using their Google account. When logging in, Trello redirects the user to Google's OAuth 2.0 server for authentication. After the user grants permissions, Google issues an OAuth token. Trello uses this token to authorize the user and grant access to their account.

The OAuth 2.0 flow can be monitored in **Chrome Developer Tools**. When the user clicks "Sign in with Google," the browser makes requests to `accounts.google.com` for the OAuth token exchange. Once successful, Trello uses the returned token for authorization and the user is logged in.

---

### **Medium**:

Medium also uses Google SSO for user authentication. The process begins by redirecting the user to Google's OAuth 2.0 authentication page. After successful login and consent, Google provides an OAuth token, which Medium uses to authorize the user.

This can be tracked in **Chrome Developer Tools** by watching the network activity. The OAuth token exchange occurs when a request is made to `accounts.google.com` to authenticate the user. Afterward, Medium retrieves user data using the token.

---

In both examples, the Google authentication flow follows the OAuth 2.0 protocol, involving token exchange and authorization, which can be observed in the **Network** tab of Chrome Developer Tools.

## 10. How do we use session and cookie to keep user information across the the application?

### Using Session and Cookie to Keep User Information

- **Session**: Stores user data (e.g., login status, preferences) on the server. A session ID is generated for each user.
- **Cookie**: Stores the session ID on the client (in the browser) and is sent with each request to the server.

The server uses the session ID from the cookie to retrieve the corresponding user data from the session, allowing the application to maintain user information across multiple requests.

## 11. What is the spring security filter?

A **Spring Security filter** is a part of the filter chain that intercepts HTTP requests and applies security measures, such as authentication and authorization, before the request reaches the application. Filters like `UsernamePasswordAuthenticationFilter` or `JwtAuthenticationFilter` extract credentials or tokens, verify them, and ensure the user has the necessary permissions to access resources. The filter chain ensures all security checks are performed in the correct order during request processing.

## 12. Explain bearer token and how JWT works.

### Bearer Token

A **Bearer Token** is an access token provided in the `Authorization` header of HTTP requests, allowing the client to access protected resources. The server validates the token and grants access if it's valid.

### How JWT Works

- **JWT (JSON Web Token)** is a compact, self-contained token used for secure data exchange.
- A JWT consists of three parts: **Header**, **Payload**, and **Signature**.
  - **Header**: Specifies the token type (JWT) and signing algorithm.
  - **Payload**: Contains claims (user data or permissions).
  - **Signature**: Verifies the token's integrity, created by signing the header and payload with a secret key.

When a client sends a JWT, the server verifies the signature and checks the claims to authenticate and authorize the user.

## 13. Explain how do we store sensitive user information such as password and credit card number in DB?

### Storing Sensitive User Information

- **Passwords**:

  - **Hashing**: Use a secure hashing algorithm (e.g., bcrypt, Argon2) to store only the hashed version of the password, not the plain text.
  - **Salting**: Add a unique random value (salt) to the password before hashing to defend against rainbow table attacks.

- **Credit Card Numbers**:
  - **Encryption**: Use strong encryption (e.g., AES) to store credit card numbers. Only authorized services should be able to decrypt and access the data.
  - **Tokenization**: Replace the actual credit card number with a token, which can be stored in the DB, while the real number is stored securely in a separate system.

**Key Practice**: Never store passwords or credit card numbers in plain text. Use encryption, hashing, and salting techniques.

## 14. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?

### Comparison of Spring Security Components

- **UserDetailsService**:

  - Loads user-specific data (e.g., username, password, roles) from a database or other source during authentication.
  - Key interface for fetching user information.

- **AuthenticationProvider**:

  - Performs the actual authentication by validating user credentials (e.g., username/password).
  - Can support different authentication methods (e.g., form login, LDAP, JWT).

- **AuthenticationManager**:

  - Delegates authentication requests to one or more `AuthenticationProvider`s.
  - Acts as the central point for authentication logic in Spring Security.

- **AuthenticationFilter**:
  - Intercepts HTTP requests and extracts credentials (e.g., username, password, JWT token).
  - Passes the credentials to `AuthenticationManager` for authentication.
  - Examples: `UsernamePasswordAuthenticationFilter`, `JwtAuthenticationFilter`.

**Summary**:

- `UserDetailsService` loads user data.
- `AuthenticationProvider` verifies credentials.
- `AuthenticationManager` coordinates authentication.
- `AuthenticationFilter` handles request-level authentication.

## 15. What is the disadvantage of Session? how to overcome the disadvantage?

### Disadvantages of Session

- **Scalability Issues**: Session data is stored server-side, making it difficult to scale across multiple servers in a distributed environment.
- **Increased Memory Usage**: Storing large amounts of session data on the server can lead to higher memory consumption.
- **Session Stickiness**: In load-balanced environments, session stickiness (keeping a user tied to one server) may be required, complicating scalability.

### How to Overcome the Disadvantages

- **Use Distributed Session Stores**: Store session data in a distributed cache (e.g., Redis, Memcached) that all servers can access, allowing for horizontal scaling.
- **Stateless Authentication (JWT)**: Use JWT tokens to store user information client-side, reducing server-side memory usage and eliminating the need for session storage on the server.

**Key Point**: Switching to distributed session stores or stateless authentication (like JWT) can overcome session scalability issues.

## 16. how to get value from application.properties in Spring security?

1. Using `@Value` Annotation:

```
@Value("${property.name}")
private String propertyValue;
```

2. Using `Environment` Object:

```
@Autowired
private Environment evn;
String propertyValue = env.getProperty("property.name");
```

## 17. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

### Role of `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)`

- **`configure(HttpSecurity http)`**:

  - Configures **authorization** rules and security for HTTP requests.
  - Defines which endpoints require authentication, form login settings, CSRF protection, and more.
  - Example:
    ```java
    http
      .authorizeRequests()
      .antMatchers("/public/**").permitAll()
      .anyRequest().authenticated();
    ```

- **`configure(AuthenticationManagerBuilder auth)`**:
  - Configures **authentication** by specifying how users are authenticated.
  - Defines custom user details, in-memory, JDBC authentication, or integrating with external systems (e.g., LDAP).
  - Example:
    ```java
    auth
      .inMemoryAuthentication()
      .withUser("user").password("{noop}password").roles("USER");
    ```

**Summary**: `HttpSecurity` configures **authorization** and web security, while `AuthenticationManagerBuilder` configures **authentication** mechanisms.

## 18. Spring Security Interview Questions by InterviewBit

[Spring Security Interview Questions](https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern)
