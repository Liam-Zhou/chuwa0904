# HW1

Yuhang Li

# 1. List all of the Spring data related annotations you learned and explain its usage.

Please refer to the annotations.md



# 2. Explain **TLS**, **PKI**, **certificate**, **public key**, **private key**, and **signature**.

Sure! Let’s break down each of these concepts:

### 1. **TLS (Transport Layer Security)**:
- **Definition**: TLS is a cryptographic protocol designed to provide secure communication over a computer network. It is the successor to SSL (Secure Sockets Layer).
- **Purpose**: TLS ensures privacy, data integrity, and authentication between two communicating applications, such as a web server and a client (browser).
- **How It Works**: TLS encrypts the data transmitted between the client and the server, making it difficult for third parties to eavesdrop or tamper with the information. It also involves a handshake process to negotiate encryption parameters and authenticate the server and, optionally, the client.

### 2. **PKI (Public Key Infrastructure)**:
- **Definition**: PKI is a framework that manages digital certificates and public-key encryption. It includes hardware, software, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates.
- **Purpose**: PKI enables secure communication and authentication by providing a way to verify the identities of parties in a transaction and to encrypt data exchanged between them.
- **Components**:
  - **Certificate Authority (CA)**: A trusted entity that issues digital certificates.
  - **Registration Authority (RA)**: Acts as the verifier for the CA before a digital certificate is issued.
  - **Digital Certificates**: Electronic documents used to prove the ownership of a public key.

### 3. **Certificate**:
- **Definition**: A digital certificate is an electronic document that contains information about the identity of the entity (such as a person, organization, or device) and its public key.
- **Contents**: A certificate typically includes:
  - **Subject**: The identity of the entity (e.g., domain name).
  - **Public Key**: The public key associated with the subject.
  - **Issuer**: The CA that issued the certificate.
  - **Validity Period**: The dates between which the certificate is valid.
  - **Signature**: The digital signature of the CA that verifies the authenticity of the certificate.
- **Purpose**: Certificates facilitate secure communication by enabling clients and servers to authenticate each other and establish encrypted connections.

### 4. **Public Key**:
- **Definition**: The public key is a cryptographic key that can be shared with anyone. It is used to encrypt data or verify digital signatures.
- **Role in Encryption**: In asymmetric encryption, data encrypted with a public key can only be decrypted with the corresponding private key. This ensures that only the owner of the private key can decrypt the data.
- **Usage**: Public keys are included in digital certificates, allowing users to verify the identity of the certificate holder.

### 5. **Private Key**:
- **Definition**: The private key is a cryptographic key that is kept secret and is used to decrypt data that was encrypted with the corresponding public key or to create digital signatures.
- **Role in Security**: The private key must be securely stored and protected. If it is compromised, an attacker can impersonate the key owner or decrypt sensitive information.
- **Usage**: Private keys are never shared and are used in conjunction with the public key to enable secure communication.

### 6. **Signature**:
- **Definition**: A digital signature is a cryptographic value that is calculated from the data being signed and the signer's private key. It provides proof of the integrity and authenticity of the data.
- **Purpose**: Digital signatures ensure that:
  - The data has not been altered in transit (integrity).
  - The data was created by a specific entity (authentication).
- **How It Works**: When data is signed, a hash of the data is created, and then it is encrypted using the signer's private key. The recipient can then verify the signature by decrypting it with the public key and comparing the hash with a newly computed hash of the received data.

### **Summary of Relationships**:
- **TLS** uses PKI to secure communications over the internet.
- **PKI** issues **certificates** that bind a public key to an entity’s identity.
- Each certificate contains a **public key** and is signed by a **Certificate Authority** (CA).
- The entity possessing the **private key** can decrypt information encrypted with its corresponding public key or create digital signatures.
- **Signatures** are used to verify the authenticity of certificates and the integrity of messages.

These components work together to ensure secure communication and authentication in various digital transactions.

# 3. Write a Spring security based application, which provides https APIs (one simple get controller with empty response is good enough ) instead of http, please generate a self-signed certificate to make your https TLS verfication work. 

## 1. Pack your self-signed certificate in the form of jks file, as part of your application, name it properly  

Please refer Coding/Coding11 for codes.

For detailed steps, please see below.

## 2. Test if you can verify your HTTPs api without importing the self-signed certificate to your local certificate chain, if not, explain why. 

### Analysis of the Question

The question asks if you can verify your **HTTPS** API **without importing the self-signed certificate** into your local certificate chain. If not, you are expected to explain why verification fails.

This question focuses on the security of **TLS/SSL** connections. In the context of using a **self-signed certificate**, let's break it down:

1. **Self-Signed Certificates**:
   - A **self-signed certificate** is one that is not issued by a trusted Certificate Authority (CA). Instead, you generate it yourself, as we did with the `keytool` command.
   
2. **Certificate Verification**:
   - When you access an HTTPS URL, the client (e.g., Postman, browser) attempts to verify the authenticity of the certificate. If the certificate is issued by a trusted CA (e.g., Let's Encrypt, Digicert), it is automatically trusted.
   - However, **self-signed certificates are not trusted** by default because they are not issued by a known CA. The client cannot confirm the authenticity of the server’s identity without adding the certificate to the trusted certificate store (certificate chain) on the client’s machine.

### Relevance to Our Steps

In our steps above:

- **Step 4**: We generated a **self-signed certificate** using `keytool` and packaged it with the Spring Boot application.
- **Step 8**: We tested the HTTPS API using Postman and received a `401 Unauthorized`, but that issue was related to Spring Security configuration, not the certificate. Now that we resolved that, we can focus on the certificate verification aspect.

If you attempt to call the HTTPS API **without importing the self-signed certificate** into your local trust store, you will likely face one of the following errors in Postman or any other client:
- **SSL Handshake Failed**.
- **Certificate is not trusted**.
- **Invalid certificate authority**.

This happens because the self-signed certificate is **not trusted** by the client unless you manually add it to your system’s trusted certificate chain.

### Why It Fails Without Importing the Certificate

The failure occurs because:
1. **Self-signed certificates are not from a trusted CA**: By default, the system (or client, like Postman) does not recognize self-signed certificates as legitimate, as they haven't been issued by a trusted entity.
   
2. **TLS/SSL Verification**: During the TLS handshake, the client checks the validity of the server’s certificate by looking it up in the local certificate chain. Since your self-signed certificate isn't there, the verification fails.

### Conclusion

If you **do not import** your self-signed certificate to your local certificate chain, the verification will fail because the certificate is not trusted by default.

- **Solution**: You can import the certificate into the system’s trusted certificate chain to resolve the issue, but the question specifically asks you to explain why it fails without doing so.

## 3. Explain what did you do to make https call work, do NOT bypass TLS/SSL verficationin Postman(this is cheating)!

For the third question, the focus is on explaining how we made the HTTPS call work **without bypassing TLS/SSL verification** in Postman, meaning we are not turning off SSL checks or skipping the certificate verification process.

### Explanation of What We Did:

1. **Generated a Self-Signed Certificate**:
   - We used the `keytool` command to generate a **self-signed certificate** in the `JKS` (Java KeyStore) format. This certificate is used by the Spring Boot application to establish HTTPS connections.
   - The `keystore` holds the certificate and private key used for TLS encryption.
   
2. **Configured Spring Boot for HTTPS**:
   - In the `application.properties`, we configured Spring Boot to use **HTTPS** by providing the path to the `JKS` file and the corresponding password.
   - We also specified the port `8443` for HTTPS to ensure that the application accepts secure connections.

3. **Kept TLS/SSL Verification On**:
   - We made sure not to **disable SSL verification** in Postman or the client. Disabling it would bypass the SSL certificate check, which we specifically want to avoid to ensure the integrity of the HTTPS connection.

   ![Screenshot 2024-10-02 at 4.04.50 PM](/Users/liyuhang/Library/Application Support/typora-user-images/Screenshot 2024-10-02 at 4.04.50 PM.png)
   
4. **Import the Self-Signed Certificate** (Critical Step):
   - To make the HTTPS call work **without bypassing TLS/SSL verification**, we need to **import the self-signed certificate into Postman's certificate chain**.
   - This involves adding the certificate to Postman’s **trusted certificates** or the **OS-level certificate store** so that Postman can verify the authenticity of the certificate when making HTTPS requests.

5. **Client-Side TLS Handshake**:
   - When Postman sends an HTTPS request, it performs a **TLS handshake** with the server. During this handshake, Postman attempts to verify the server’s certificate.
   - Since we added the self-signed certificate to Postman's trusted store (or the OS), Postman recognizes it as valid, allowing the handshake to complete successfully, and the request proceeds without errors.

### Key Points:
- **No bypassing**: TLS/SSL verification was kept enabled, and we did not skip the certificate check. Instead, we imported the certificate into Postman or the OS certificate chain.
- **Ensuring Security**: This process ensures that the communication is encrypted, secure, and that Postman trusts the server (because it recognizes the certificate we added).
  
### Why Not Bypass SSL Verification?
- Bypassing SSL/TLS verification (e.g., turning off SSL checks in Postman) would allow insecure connections and defeat the purpose of using HTTPS.
- HTTPS ensures the **confidentiality** and **integrity** of data between the client and server. By properly handling the self-signed certificate, we maintain these security guarantees without compromising on verification.

## 4. Detailed Steps and Screenshots

Spring Boot application named **HW_CODING_11** and configuring it to provide HTTPS APIs with a self-signed certificate. Here’s a step-by-step guide:

### Step 1: Create a Spring Boot Application

1. **Open IntelliJ IDEA**:
   - Launch IntelliJ IDEA.

2. **Create a New Project**:
   - On the welcome screen, click on **New Project**.
   - In the left pane, select **Spring Initializr**.

3. **Project Metadata**:
   - **Group**: `com.example`
   - **Artifact**: `HW_CODING_11`
   - **Name**: `HW_CODING_11`
   - **Description**: (optional)
   - **Package name**: `com.example.hwcoding11`
   - **Packaging**: `Jar`
   - **Java Version**: Select your preferred Java version (e.g., 11 or 17).

4. **Add Dependencies**:
   - Click on **Add Dependencies** and search for:
     - **Spring Web**: For building web applications.
     - **Spring Security**: For securing your application.
   - Click **Next** and then **Finish**.

### Step 2: Verify Project Structure

1. **Project Structure**:
   - After the project is created, you should see the following directories:
     - `src/main/java`: For your Java source files.
     - `src/main/resources`: For your application properties file and other resources.
     - `pom.xml`: The Maven build file.

### Step 3: Create the Main Application Class

1. **Create Main Class**:
   - In `src/main/java/com/example/hwcoding11`, create a class called `HW_CODING_11_Application`:
   ```java
   package com.example.hwcoding11;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class HW_CODING_11_Application {
       public static void main(String[] args) {
           SpringApplication.run(HW_CODING_11_Application.class, args);
       }
   }
   ```

### Step 4: Generate a Self-Signed Certificate

1. **Open Terminal**:
   - On your MacBook, open the Terminal.

2. **Generate a Self-Signed Certificate**:
   ```bash
   keytool -genkeypair -alias myselfsigned -keyalg RSA -keystore mykeystore.jks -keysize 2048
   ```
   - Follow the prompts to fill in the details and set a password.

     ![Screenshot 2024-10-02 at 3.55.33 PM](/Users/liyuhang/Library/Application Support/typora-user-images/Screenshot 2024-10-02 at 3.55.33 PM.png)
   
3. **Move the JKS File**:
   - Move `mykeystore.jks` to the `src/main/resources` directory of the project.

### Step 5: Configure HTTPS in `application.properties`

1. **Open `application.properties`**:
   - In `src/main/resources/application.properties`, add the following configurations:
   ```properties
   server.port=8443
   server.ssl.key-store=classpath:mykeystore.jks
   server.ssl.key-store-password=patrick    // same as what we set in the above step
   server.ssl.keyStoreType=JKS
   server.ssl.keyAlias=myselfsigned
   ```

### Step 6: Create a Simple Controller

1. **Create Controller Class**:
   - In `src/main/java/com/example/hwcoding11`, create a class called `MyController`:
   ```java
   package com.example.hwcoding11;
   
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   public class MyController {
       @GetMapping("/api/test")
       public void testEndpoint() {
           // Empty response
       }
   }
   ```

2. **Modify the `SecurityConfig` Class**:

- In `src/main/java/com/example/hwcoding11/SecurityConfig.java`, replace the existing code with the following configuration:

```java
package com.example.hwcoding11;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // Disable CSRF using the newer lambda style
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/test").permitAll() // Allow access to the test endpoint
                .anyRequest().authenticated() // All other requests require authentication
            );
        return http.build();
    }

    // Optional: Define an in-memory user if authentication is needed
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        return new InMemoryUserDetailsManager(user);
    }
}
```



### Step 7: Run the Application

1. **Run the Application**:
   - Right-click on the `HW_CODING_11_Application` class and select **Run 'HW_CODING_11_Application.main()'**.

### Step 8: Test the HTTPS API

1. **Test the API: Postman:**
   
   ```bash
   GET https://localhost:8443/api/test
   ```

2. **Explain TLS Verification**:
   
   - Without importing the self-signed certificate, you'll likely see an error indicating that the certificate is not trusted.

![Screenshot 2024-10-02 at 3.58.37 PM](/Users/liyuhang/Library/Application Support/typora-user-images/Screenshot 2024-10-02 at 3.58.37 PM.png)





### Summary

Now you have created a Spring Boot application named **HW_CODING_11**, configured it for HTTPS, and implemented a simple GET API. If you have any questions or need further assistance with any of the steps, let me know!





# 4. List all http status codes that related to authentication and authorization failures.

Here’s a list of HTTP status codes specifically related to authentication and authorization failures, along with brief descriptions of each:

### **Authentication-Related Status Codes**:

1. **401 Unauthorized**
   - **Description**: The request requires user authentication. The server sends this status code when the user has not provided valid authentication credentials or when the provided credentials are incorrect.

2. **403 Forbidden**
   - **Description**: The server understood the request but refuses to authorize it. This status code indicates that the server is refusing to fulfill the request, regardless of whether the user is authenticated.

### **Authorization-Related Status Codes**:

3. **403 Forbidden**
   - **Description**: As mentioned above, it indicates that the user is authenticated but does not have permission to access the requested resource.

4. **407 Proxy Authentication Required**
   - **Description**: This status code indicates that the client must first authenticate itself with the proxy server. It is similar to 401 Unauthorized, but specifically for proxy authentication.

### **Other Related Status Codes**:

5. **400 Bad Request**
   - **Description**: Although not directly an authentication failure, this status code can occur when the request is malformed, which may include issues with credentials being sent in the request.

6. **404 Not Found**
   - **Description**: This can indicate that the resource does not exist or that the client is not authorized to access it. While not an authentication error per se, it may sometimes relate to authorization when the resource is hidden from unauthorized users.

7. **419 Authentication Timeout (Not Standard)**
   - **Description**: Some frameworks or applications may use this code to indicate that the authentication session has expired. This is not part of the official HTTP status codes but can be seen in specific applications.

8. **451 Unavailable For Legal Reasons**
   - **Description**: This status code indicates that the server is denying access to the resource as a consequence of a legal demand. While not strictly about authentication or authorization, it can affect access to certain resources.

### **Summary**:
- **401 Unauthorized**: Missing or invalid authentication credentials.
- **403 Forbidden**: Authenticated but lacks permission to access the resource.
- **407 Proxy Authentication Required**: Authentication needed for proxy access.
- **400 Bad Request**: Malformed request potentially related to credentials.
- **404 Not Found**: Resource not found, which may involve authorization.
- **419 Authentication Timeout**: Session expiration (non-standard).
- **451 Unavailable For Legal Reasons**: Access denied due to legal reasons.

These status codes help clients understand the nature of authentication and authorization issues when interacting with web services and APIs.

# 5. Compare **authentication** and **authorization**? Name and explain important components in Spring security that undertake **authentication** and **authorization**.

Authentication 验证用户能否登录, who are you.

Authorization 用户有没有访问某个API的权限。can this user do this? 比如普通用户访问不了设定为admin的权限。

in amazon, Buyer account can call the APIs belonged to Seller?



**Authorization** and **Authentication** are two key concepts in the realm of security, especially in web applications and services. While they are often used together, they serve distinct purposes:

### 1. **Authentication**:

- **What is it?**:
  - **Authentication** is the process of verifying the identity of a user or entity. It's about confirming that the user is who they claim to be.
  - This typically involves verifying credentials like a username and password, biometric data (like a fingerprint), or a security token.

- **How it works**:
  - The user provides credentials (e.g., a username and password).
  - The system checks the credentials against a database or other authentication system to confirm the user’s identity.
  - If the credentials are correct, the user is authenticated and can proceed.

- **Key Goal**:
  - Prove the user’s identity.

- **Example**:
  - When you log into a website with your email and password, the system checks if those credentials are correct and then logs you in.

- **Common Authentication Methods**:
  - **Password-based**: Traditional username and password combinations.
  - **Biometric**: Fingerprint, facial recognition, retina scan.
  - **Two-Factor Authentication (2FA)**: Using a second form of authentication, like a one-time password (OTP) sent to your phone.
  - **OAuth**: Token-based authentication where a third-party service (like Google or Facebook) verifies the user’s identity.

---

### 2. **Authorization**:

- **What is it?**:
  - **Authorization** is the process of determining what actions a user is allowed to perform or what resources they can access once they are authenticated.
  - It involves granting or denying access to certain resources based on the user's permissions or roles.

- **How it works**:
  - **After** the user is authenticated, the system checks their permissions to see if they are authorized to access certain resources or perform specific actions.
  - This is typically managed using roles, policies, or access control lists (ACLs).

- **Key Goal**:
  - Determine what the user is allowed to do.

- **Example**:
  - After logging into a web application, different users might have different access levels. For example, an "admin" user can create, edit, or delete content, while a "regular" user can only view content.

- **Common Authorization Models**:
  - **Role-Based Access Control (RBAC)**: Permissions are assigned based on the user’s role (e.g., admin, editor, viewer).
  - **Attribute-Based Access Control (ABAC)**: Access is granted based on attributes of the user, resource, or environment (e.g., user location, time of access).
  - **OAuth Scopes**: In OAuth, authorization is based on "scopes" which specify what resources or actions the authenticated user can access.

---

### **Key Differences**:

| **Aspect**          | **Authentication**                                         | **Authorization**                                            |
| ------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **Purpose**         | Verifying the user’s identity                              | Defining what actions or resources the user can access       |
| **When it happens** | Before authorization; the user must be authenticated first | After authentication; permissions are checked after the user’s identity is confirmed |
| **Examples**        | Logging in with a password or biometric data               | Accessing an admin dashboard or editing content based on user role |
| **Focus**           | "Who are you?"                                             | "What are you allowed to do?"                                |
| **Data Involved**   | Credentials (e.g., username, password, tokens)             | Permissions, roles, or policies tied to the user             |

---

### **How They Work Together**:

- **Authentication** happens first. Once the user is authenticated and their identity is verified, **authorization** follows to determine what resources or actions the user can access based on their permissions.
- **Example flow:**
  1. A user tries to log in with their credentials.
  2. The system authenticates the user by verifying their credentials.
  3. Once authenticated, the system checks the user's roles or permissions (authorization) to determine what resources they can access or what actions they can perform.

---

### **Summary**:

- **Authentication** is about verifying **who** the user is.
- **Authorization** is about determining **what** the authenticated user is allowed to do.

Both are critical components in securing applications, and they typically work together to ensure that only authenticated and authorized users can access sensitive resources or perform certain actions.



# 6. Explain HTTP Session?

- **What are Sessions?**:
  - A session is a way to store **user-specific data server-side**. When a user logs in, the server creates a **session ID** and stores user information (like login state, roles, etc.) associated with that ID on the server.
  - The client holds the session ID in a cookie and sends it to the server with each request. The server then retrieves the user's session data using that session ID.

- **How they work**:
  - When a user logs in, the server generates a unique session ID and stores relevant data (e.g., authentication status, user info) associated with that session ID.
  - The session ID is sent to the client in a cookie. On each request, the client sends the session ID back to the server, allowing the server to retrieve the user's session data and continue the interaction without re-authentication.

- **Use Cases**:
  - **Authentication**: Once a user logs in, their authentication state can be stored in the session, allowing the server to recognize authenticated users on subsequent requests.
  - **Shopping Carts**: E-commerce sites use sessions to store items added to the shopping cart across different pages.

- **Session Lifetime**:
  - Sessions are typically **temporary** and last until the user logs out or the session expires (usually defined by a timeout).
  - Servers typically store session data in memory, databases, or caching layers like **Redis**.

- **Security Concerns**:
  - **Session Hijacking**: Attackers can steal session cookies to impersonate a user. Secure cookies and proper session management are essential to mitigate this.

# 7. Explain Cookie?

- **What are Cookies?**: 
  - Cookies are **small pieces of data stored on the client (browser) by the server.** They allow the server to remember information about the client between requests.
  - Cookies are typically sent with every HTTP request to the server and are widely used to maintain session data across multiple page requests.

- **How they work**:
  - The server sends a cookie to the client in the HTTP response (usually during authentication), and the client stores it.
  - On subsequent requests, the client sends the cookie back to the server, allowing the server to identify the user and track their session.

- **Use Cases**:
  - **Session Management**: Cookies store session IDs that identify a user’s session on the server.
  - **User Preferences**: They can store small pieces of information such as language preferences, theme settings, etc.

- **Security Concerns**:
  - **Cookies are vulnerable to attacks** like **Cross-Site Scripting (XSS)** and **Cross-Site Request Forgery (CSRF)**.
  - To secure cookies, attributes such as **HttpOnly**, **Secure**, and **SameSite** are commonly used.

# 8. Compare Session and Cookie?

### **Summary of Differences**:

| **Aspect**         | **Cookies**                                | **Sessions**                                    | **Tokens**                                       |
| ------------------ | ------------------------------------------ | ----------------------------------------------- | ------------------------------------------------ |
| **Where stored**   | On the client (browser)                    | Data stored on the server, session ID in cookie | On the client (localStorage, cookies, etc.)      |
| **State**          | Stateful                                   | Stateful (server stores user data)              | Stateless (all info in token itself)             |
| **Data Location**  | Client-side                                | Server-side                                     | Client-side (tokens passed to server on request) |
| **Lifetime**       | Based on cookie expiry (can be long-lived) | Session expires after logout or timeout         | Typically short-lived with refresh tokens        |
| **Security Risks** | Vulnerable to XSS, CSRF                    | Vulnerable to session hijacking                 | Token theft; no built-in revocation mechanism    |
| **Usage**          | Session IDs, preferences                   | Persistent user sessions                        | API authentication, stateless auth               |

# 9. Find **at least TWO** websites who can be logged in using your **Google Account**, explain in detail on how Google SSO works with screenshots like below, find SSO-related Rest calls in Chrome developer tool:

To illustrate how Google Single Sign-On (SSO) works, I'll provide examples of two websites where you can log in using your Google account: **YouTube** and **Slack**. Additionally, I’ll explain the process and guide you through finding SSO-related REST calls in the Chrome Developer Tools. 

### **1. YouTube**

#### How Google SSO Works with YouTube:

1. **Login Prompt**: 
   - When you visit YouTube and click on the “Sign in” button, you are presented with options to log in using your Google account.
   
2. **Redirect to Google**:
   - Clicking the "Sign in with Google" button redirects you to the Google authentication page, where you can enter your Google credentials.

3. **Consent Screen**:
   - After entering your credentials, you may see a consent screen asking for permission to allow YouTube to access your Google account information.

4. **Successful Authentication**:
   - If you accept, Google authenticates you and redirects you back to YouTube, logging you in without the need to create a separate username or password for YouTube.


#### Finding SSO-related REST Calls:

- Open Chrome Developer Tools (F12 or right-click and select "Inspect").
- Go to the **Network** tab.
- Filter by "XHR" or "Fetch" to see AJAX requests.
- Look for requests made to Google’s OAuth endpoints (like `https://accounts.google.com/o/oauth2/...`) that contain the access token in the response headers.

### **2. Slack**

#### How Google SSO Works with Slack:

1. **Login Prompt**:
   - When you visit Slack and click on “Sign in,” you can select to sign in with your Google account.

2. **Redirect to Google**:
   - Clicking “Sign in with Google” redirects you to the Google authentication page.

3. **Consent Screen**:
   - After entering your credentials, you may see a consent screen asking for permission to allow Slack to access your Google account information.

4. **Successful Authentication**:
   - After granting permission, Slack logs you in and redirects you to your Slack workspace.


#### Finding SSO-related REST Calls:

- Open Chrome Developer Tools (F12).
- Go to the **Network** tab.
- Filter for "XHR" or "Fetch" requests.
- Look for requests made to Google’s OAuth endpoints similar to YouTube and note the access token in the response headers.

### **Summary of How Google SSO Works**:

1. **Initiation**: The user clicks on the "Sign in with Google" option on a third-party site (like YouTube or Slack).
2. **Redirection**: The user is redirected to Google’s OAuth 2.0 server.
3. **User Authentication**: The user enters their Google credentials.
4. **Consent**: The user grants permissions for the third-party site to access specific Google account information.
5. **Token Exchange**: Google generates an access token and redirects the user back to the third-party site.
6. **Access Granted**: The third-party site uses the access token to authenticate the user and allow access.

### **Finding REST Calls in Chrome Developer Tools**:
- The Developer Tools allow you to inspect network requests to understand the authentication flow, including token exchanges and response data, which are crucial for debugging and security analysis.



# 10. How do we use session and cookie to keep user information across the the application?

To keep user information across an application using sessions and cookies, follow these steps:

1. **Sessions**:
   - Store user-specific data (like user ID, authentication status) on the server-side when a user logs in.
   - Create a unique session ID for each user session and store it in the server's memory or a database.
   - Send this session ID to the client as a cookie.

2. **Cookies**:
   - Use cookies to store small pieces of data (like preferences or login tokens) on the client-side.
   - Set cookies with appropriate expiration times and secure flags to enhance security.
   - When the user makes a request, the browser automatically includes the cookie, allowing the server to retrieve the corresponding session data.

This combination allows for secure user identification and personalization throughout the application.

# 11. What is the **spring security filter**?

A **Spring Security Filter** is a component of the Spring Security framework that intercepts HTTP requests and responses to perform security-related tasks. Filters are used to enforce security constraints on web applications, providing features such as authentication, authorization, and request/response modification.

### Key Features of Spring Security Filters:

1. **Interception**: Filters are part of a chain that processes incoming requests before they reach the application and outgoing responses before they are sent to the client.

2. **Authentication**: They handle user authentication by validating credentials and creating security contexts that hold user details.

3. **Authorization**: Filters check whether a user has the necessary permissions to access specific resources.

4. **CSRF Protection**: Some filters protect against Cross-Site Request Forgery (CSRF) attacks by validating requests.

5. **Security Context Management**: They manage the security context, allowing the application to access user details securely.

6. **Custom Filters**: Developers can create custom filters to implement specific security logic tailored to application requirements.

### Common Filters in Spring Security:

- **UsernamePasswordAuthenticationFilter**: Handles username and password authentication.
- **BasicAuthenticationFilter**: Supports basic authentication schemes.
- **CsrfFilter**: Provides CSRF protection.
- **ExceptionTranslationFilter**: Handles authentication and access-denied exceptions.

These filters are configured in the security configuration, allowing you to specify the order in which they are applied and customize their behavior as needed.

# 12. Explain **bearer token** and how **JWT** works.

### Bearer Token

A **Bearer Token** is an access token that is passed in the HTTP request header to authenticate requests to a server. It allows the client to gain access to protected resources without needing to provide credentials (like username and password) repeatedly. The token acts as a key that grants access, and it is typically included in requests as follows:

```
Authorization: Bearer <token>
```

### JSON Web Token (JWT)

**JWT (JSON Web Token)** is a popular method for implementing bearer tokens, providing a compact and self-contained way to transmit information between parties securely. Here's how JWT works:

1. **Structure**: A JWT consists of three parts:
   - **Header**: Contains metadata about the token, including the type of token (JWT) and the signing algorithm used (e.g., HMAC SHA256).
   - **Payload**: Contains the claims (the information being transmitted), such as user ID, roles, and expiration time. Claims can be standard (like `iat`, `exp`, `sub`) or custom.
   - **Signature**: Created by signing the encoded header and payload using a secret key (or private key for asymmetric algorithms). This ensures the token's integrity and authenticity.

   The structure looks like this:
   ```
   header.payload.signature
   ```

2. **Token Creation**:
   - Upon successful authentication (e.g., after a user logs in), the server generates a JWT and sends it back to the client.
   - The client stores the JWT (often in local storage or a cookie) and includes it in the `Authorization` header for subsequent requests.

3. **Token Verification**:
   - When the server receives a request with a JWT, it decodes the token and verifies the signature using the same secret key.
   - If the signature is valid, the server processes the request based on the claims in the payload.

4. **Expiration**: JWTs often include an expiration time (`exp` claim), after which they are no longer valid. This improves security by limiting the lifespan of tokens.

### Benefits of Using JWT:
- **Stateless**: JWTs are self-contained, meaning the server doesn’t need to store session information, allowing for scalability.
- **Cross-Domain**: They can be used across different domains, making them suitable for distributed systems.
- **Flexible**: Custom claims can be added to meet specific application needs.

### Summary

Bearer tokens, particularly in the form of JWTs, are a secure and efficient way to manage authentication and authorization in modern web applications. They facilitate stateless communication and provide a simple mechanism for access control across different services.

# 13. Explain how do we store sensitive user information such as password and credit card number in DB?

Storing sensitive user information such as passwords and credit card numbers in a database requires careful handling to ensure data security and compliance with best practices. Here’s how to do it:

### Storing Passwords

1. **Hashing**:
   - **Use Strong Hashing Algorithms**: Store passwords as hashed values rather than plain text. Use algorithms like bcrypt, Argon2, or PBKDF2, which are designed for securely hashing passwords.
   - **Salting**: Add a unique, random salt to each password before hashing. This prevents attacks using precomputed hash tables (rainbow tables) by ensuring that the same password will have a different hash each time.

2. **Key Stretching**: Configure the hashing algorithm to perform multiple iterations (e.g., 10,000 iterations with bcrypt) to make brute-force attacks more time-consuming.

3. **Storing Hashes**: Store the hashed password and the salt in the database. When a user logs in, hash the provided password with the stored salt and compare it to the stored hash.

### Storing Credit Card Numbers

1. **Encryption**:
   - **Use Strong Encryption Algorithms**: Encrypt sensitive data like credit card numbers using strong encryption algorithms (e.g., AES-256).
   - **Key Management**: Store encryption keys securely, separate from the encrypted data. Use a key management system (KMS) or hardware security module (HSM) for enhanced security.

2. **Tokenization**:
   - **Tokenize Credit Card Data**: Replace sensitive credit card information with a non-sensitive equivalent (token). Store the mapping of tokens to original credit card numbers in a secure environment.
   - **Use a Third-Party Payment Processor**: Consider using third-party payment gateways (e.g., Stripe, PayPal) that handle credit card processing and storage. This minimizes the risk and compliance burden.

3. **Access Controls**: Implement strict access controls to limit who can access sensitive data. Use role-based access control (RBAC) and audit logs to track access to sensitive information.

### Additional Best Practices

- **Compliance**: Ensure compliance with regulations such as PCI DSS (Payment Card Industry Data Security Standard) for handling credit card information and GDPR (General Data Protection Regulation) for personal data.
- **Regular Security Audits**: Conduct regular security audits and vulnerability assessments to identify and mitigate risks.
- **User Education**: Educate users on the importance of password complexity and avoiding sharing sensitive information.

By following these guidelines, you can significantly enhance the security of sensitive user information stored in your database.

# 14. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这几 个名字看熟悉也行)

In Spring Security, `UserDetailsService`, `AuthenticationProvider`, `AuthenticationManager`, and `AuthenticationFilter` are key components involved in the authentication process. Here’s a comparison of these components:

### 1. UserDetailsService

- **Purpose**: Responsible for retrieving user-related data.
- **Functionality**: Loads a user’s details (such as username, password, roles) from a data source (like a database) based on the username.
- **Method**: The main method is `loadUserByUsername(String username)`, which returns a `UserDetails` object.
- **Usage**: Used by the `AuthenticationManager` to get user details during authentication.

### 2. AuthenticationProvider

- **Purpose**: Validates user credentials against the information provided by `UserDetailsService`.
- **Functionality**: Contains the logic to authenticate a user and returns an `Authentication` object if successful.
- **Methods**: The main method is `authenticate(Authentication authentication)`, which checks the credentials and returns an `Authentication` object or throws an exception if authentication fails.
- **Usage**: Can be configured to support multiple authentication methods (e.g., username/password, OAuth).

### 3. AuthenticationManager

- **Purpose**: Acts as a central point for authentication logic.
- **Functionality**: Delegates authentication requests to one or more `AuthenticationProvider` instances.
- **Methods**: The primary method is `authenticate(Authentication authentication)`, which calls the appropriate `AuthenticationProvider` to perform the authentication.
- **Usage**: Typically used in the authentication process, often integrated with `AuthenticationFilter` to handle login requests.

### 4. AuthenticationFilter

- **Purpose**: Intercepts incoming HTTP requests to extract authentication information.
- **Functionality**: Processes authentication requests (like login) by extracting credentials from the request (e.g., headers, form data) and creating an `Authentication` object.
- **Methods**: Commonly overrides the `doFilterInternal()` method to handle the authentication logic.
- **Usage**: Typically added to the Spring Security filter chain, intercepting requests before they reach the application.

### Summary of Roles and Interactions

- **UserDetailsService** retrieves user data.
- **AuthenticationProvider** validates credentials against the user data.
- **AuthenticationManager** coordinates the authentication process by using `AuthenticationProvider`.
- **AuthenticationFilter** captures authentication requests from users and passes them to the `AuthenticationManager`.

These components work together to facilitate a secure authentication process within a Spring Security application, ensuring that user credentials are correctly validated and authenticated.

# 15. What is the disadvantage of Session? How to overcome the disadvantage?

While sessions are widely used for managing user state in web applications, they come with several disadvantages. Here are some key disadvantages and ways to overcome them:

### Disadvantages of Sessions

1. **Scalability Issues**:
   - Sessions typically store user data on the server, which can lead to scalability challenges as the number of users increases. The server needs to manage the state, which can consume memory and resources.

2. **Server Dependency**:
   - If the server crashes or restarts, all active sessions may be lost unless stored in a persistent store. This makes the application vulnerable to session loss.

3. **Load Balancing Complications**:
   - In a distributed environment, maintaining session consistency across multiple servers can be complex. Without proper management, a user might be directed to different servers, leading to session mismatches.

4. **Security Risks**:
   - Sessions are susceptible to attacks such as session fixation and session hijacking. If a malicious user gains access to a session ID, they can impersonate the user.

5. **User Experience**:
   - Users can lose their session if they remain inactive for a period of time, leading to potential frustration.

### Overcoming Session Disadvantages

1. **Use Stateless Authentication**:
   - Implement **token-based authentication** (e.g., JWT). This allows the server to remain stateless since all the necessary information is contained in the token itself, reducing server resource usage and improving scalability.

2. **Persistent Session Storage**:
   - Store session data in a **distributed cache** (e.g., Redis, Memcached) or a **database**. This ensures that session data can be retrieved even after server restarts or crashes.

3. **Sticky Sessions**:
   - Implement **sticky sessions** in load balancers to ensure that all requests from a user go to the same server, maintaining session consistency.

4. **Session Management Best Practices**:
   - Use secure, randomly generated session IDs and implement proper session expiration policies to minimize risks of hijacking.
   - Use HTTPS to encrypt session IDs and other sensitive data during transmission.

5. **Implement Inactivity Timeouts**:
   - Set inactivity timeouts to automatically log users out after a period of inactivity, which can help mitigate session hijacking risks.

By adopting these strategies, you can effectively manage and mitigate the disadvantages associated with using sessions in your web applications.

# 16. How to get value from application.properties in Spring security?

In Spring applications, including those using Spring Security, you can easily access values from the `application.properties` (or `application.yml`) file by using the `@Value` annotation or the `Environment` object. Here’s how you can do it:

### 1. Using `@Value` Annotation

You can use the `@Value` annotation to inject properties directly into your Spring-managed beans. Here’s an example:

**application.properties**:
```properties
app.security.secret=mySecretKey
```

**Security Configuration Class**:
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Value("${app.security.secret}")
    private String secretKey;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Use the secretKey in your security configuration
        http
            .authorizeRequests()
            .anyRequest().authenticated()
            .and()
            .csrf().disable();
        // Example of using the secretKey
        System.out.println("Secret Key: " + secretKey);
    }
}
```

### 2. Using `Environment` Object

Alternatively, you can use the `Environment` object to get property values. This approach is useful when you need to access multiple properties dynamically.

**Security Configuration Class**:
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private Environment env;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        String secretKey = env.getProperty("app.security.secret");
        
        // Use the secretKey in your security configuration
        http
            .authorizeRequests()
            .anyRequest().authenticated()
            .and()
            .csrf().disable();
        
        // Example of using the secretKey
        System.out.println("Secret Key: " + secretKey);
    }
}
```

### Summary

- Use the `@Value` annotation for direct property injection into fields.
- Use the `Environment` object when you need to access multiple properties dynamically or when you want to manage properties programmatically.

Both methods are effective for accessing values from the `application.properties` file in Spring Security configurations.

# 17. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

In Spring Security, the `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)` methods play crucial roles in setting up security configurations for web applications. Here’s an overview of their roles:

### 1. `configure(HttpSecurity http)`

**Role**: This method is used to configure HTTP security for the application.

- **Purpose**: It defines the security constraints on HTTP requests, including which endpoints are secured, what type of authentication is required, and what security features (like CSRF protection) should be enabled or disabled.
  
- **Common Configurations**:
  - **Authorization**: Specify which roles or authorities are allowed to access particular URL patterns.
  - **Form-Based Login**: Configure form-based authentication, including login page URLs and success/failure handlers.
  - **CSRF Protection**: Enable or disable CSRF protection, which helps prevent Cross-Site Request Forgery attacks.
  - **Session Management**: Define how sessions are managed, including session fixation protection and concurrent session control.
  
- **Example**:
    ```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/public/**").permitAll() // Allow access to public resources
            .anyRequest().authenticated() // Secure all other requests
            .and()
            .formLogin() // Enable form-based authentication
            .loginPage("/login") // Custom login page
            .permitAll() // Allow everyone to access the login page
            .and()
            .logout() // Enable logout functionality
            .permitAll();
    }
    ```

### 2. `configure(AuthenticationManagerBuilder auth)`

**Role**: This method is used to configure authentication mechanisms and providers.

- **Purpose**: It sets up how user authentication is handled, specifying where and how user credentials are validated (e.g., in-memory, database, custom user details service).

- **Common Configurations**:
  - **UserDetailsService**: Specify a custom `UserDetailsService` for loading user-specific data (e.g., username, password, roles).
  - **In-Memory Authentication**: Define users and their roles directly in the configuration for testing or simple applications.
  - **Password Encoding**: Set up password encoders to hash and verify passwords securely.
  
- **Example**:
    ```java
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication() // Use in-memory authentication for demo purposes
            .withUser("user").password("{noop}password").roles("USER") // Define a user
            .and()
            .withUser("admin").password("{noop}admin").roles("ADMIN"); // Define an admin user
    }
    ```

### Summary

- **`configure(HttpSecurity http)`**: Focuses on securing HTTP requests and defining authorization rules, login/logout configurations, and CSRF protection.
  
- **`configure(AuthenticationManagerBuilder auth)`**: Focuses on setting up authentication mechanisms, such as how to load user details and validate credentials.

Together, these methods provide a comprehensive way to define security behavior for a Spring-based web application.
