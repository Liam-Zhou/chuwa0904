# HW12 Spring AOP

## 1. List all of the annotations you learned from this class session.

1. @ComponentScan(basePackages = { "com.chuwa.training" }):

- Scans the specified base package for Spring components (like @Controller, @Service, @Repository, etc.).

2. @PutMapping(value = "/{id}", produces = "application/xml", consumes = "application/json"):

- Handles HTTP PUT requests.
- The value attribute defines the URL pattern.
- The produces attribute specifies the media type (e.g., XML) that the method will produce in the response.
- The consumes attribute specifies the media type (e.g., JSON) that the method expects in the request body.

3. @RestController:

- A convenience annotation that combines @Controller and @ResponseBody.
- Used to simplify the creation of RESTful web services by returning the response directly as an object in the form of JSON or XML.

## 2. techgeeknext spring aop interview question

[AOP interview question](https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions)

## 3. What is the Aspect Oriented Programming, explain it with detailed use cases?

### Aspect-Oriented Programming (AOP)

**Aspect-Oriented Programming (AOP)** is a programming paradigm that allows the separation of **cross-cutting concerns** (like logging, security, or transaction management) from the core business logic of an application. It improves modularity by enabling these concerns to be defined separately as **aspects** and applied across different parts of the program.

### Key Concepts:

- **Aspect**: A module that encapsulates cross-cutting concerns.
- **Join Point**: A point in the program where additional behavior can be applied (e.g., method execution).
- **Advice**: Code executed at a specific join point (before, after, or around).
- **Pointcut**: Expression to specify which join points are intercepted.
- **Weaving**: The process of applying aspects to the target code.

### Use Cases:

1. **Logging**: Automatically log method entry/exit without modifying each method.

```java
@Before("execution(* com.example.*.*(..))")
public void logBefore(JoinPoint joinPoint) {
  System.out.println("Entering method: " + joinPoint.getSignature().getName());
  }
```

2. **Security** Apply permision checks across methods in a centralized way.

```java
@Before("execution(* com.example.secured.*.*(..))")
public void checkPermission() {
  if (!userHasPermission()) {
      throw new SecurityException("Access Denied");
  }
}
```

3. **Transaction Management**: Handle database transactions around method executions.

```java
@Around("execution(* com.example.dao.*.*(..))")
public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
    beginTransaction();
    Object result = joinPoint.proceed();
    commitTransaction();
    return result;
}
```

## 4. What are the advantages and disadvantages of Spring AOP?

### Advantages of Spring AOP

1. **Separation of Concerns**: Cross-cutting concerns like logging, security, and transaction management are separated from business logic, making the code cleaner and more maintainable.
2. **Modularity**: Aspects can be defined separately and applied to various parts of the application without modifying the core code.
3. **Ease of Use**: Spring AOP is easy to use with annotations and XML configuration, requiring minimal changes to existing codebases.
4. **Declarative Approach**: It allows declarative management of concerns (e.g., transactions) without manually coding it into the business logic.
5. **Integration with Spring Framework**: Works seamlessly with other Spring modules, making it a natural choice for Spring-based applications.

### Disadvantages of Spring AOP

1. **Limited to Method-Level Interception**: Spring AOP primarily works at the method level, and doesn’t provide full support for field-level or constructor interception (unlike AspectJ).
2. **Runtime Overhead**: Since Spring AOP is proxy-based, it can introduce some runtime overhead, especially in high-performance applications.
3. **Limited Weaving**: Spring AOP supports only runtime weaving (through proxies), whereas AspectJ supports compile-time and load-time weaving, which can be more powerful and efficient.
4. **Complex Debugging**: Debugging aspects and advice can be more challenging, as the code is applied dynamically, making it harder to trace through regular debugging tools.

## 5. Explain following concept in your own words, you may include code snippet as part of your answer.

**1. Aspect**

An Aspect in Spring AOP is a modularization of a concern that cuts across multiple objects. It is a class that encapsulates behaviors that affect multiple classes in a Spring application, such as logging, transaction management, or security. Aspects enable the separation of cross-cutting concerns from business logic, making the codebase cleaner and more maintainable.

e.g.

```java
@Aspect
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethodExecution() {
        System.out.println("Executing method...");
    }
}
```

In this example, the `LoggingAspect` is an aspect that adds logging behavior before the execution of any method in the `service` package.

**2. PointCut**

A PointCut is an expression that defines at which join points (points in the program execution, like method calls) an advice should be applied. It helps in determining where exactly an aspect’s advice will be executed. The pointcut expression can match method names, classes, packages, or even arguments.

```java
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceLayer() {}
```

In this example, the `serviceLayer()` pointcut expression defines a pattern that matches all method executions within the `service` package.

**3. JoinPoint**

A **JoinPoint** represents a point during the execution of a program, such as a method call or exception handling, where an advice can be applied. In Spring AOP, a join point is always a method execution. Through JoinPoint, you can access details like the method signature, the arguments passed, and the target object.

e.g.

```java
@Aspect
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logMethodDetails(JoinPoint joinPoint) {
        System.out.println("Method: " + joinPoint.getSignature().getName());
        System.out.println("Arguments: " + Arrays.toString(joinPoint.getArgs()));
    }
}
```

Here, the `JoinPoint` provides access to method details before its execution.

**4. Advice**

An **Advice** is the action taken by an aspect at a particular join point. In Spring AOP, there are different types of advices: `Before`, `After`, `AfterReturning`, `AfterThrowing`, and `Around`. Each type of advice specifies when the logic should be executed concerning the join point.

```java
@Aspect
public class TransactionAspect {

    @Around("execution(* com.example.service.*.*(..))")
    public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Starting transaction");
        Object result = joinPoint.proceed();  // Proceed with the target method
        System.out.println("Committing transaction");
        return result;
    }
}
```

In this example, Around advice wraps around the method execution, allowing custom logic to be executed both before and after the method call.

## 6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.

### How?

To declare a pointcut in Spring AOP, you can either use the `@Pointcut` annotation with an empty method or declare the pointcut expression directly inside the advice annotation.

### Can we declare a pointcut without an empty method?

Yes, you can declare a pointcut directly inside an advice annotation without using a separate `@Pointcut` method.

e.g.

```java
@Before("execution(* com.example.service.*.*(..))")
public void logBeforeMethodExecution() {
    // Advice logic
}
```

### Common Pointcut Expressions.

**1. execution()** : Matches method execution based on method signature.

```java
execution(modifiers-pattern? return-type-pattern declaring-type-pattern? method-name-pattern(param-pattern) throws-pattern?)
```

e.g.

```java
execution(* com.example.service.*.*(..))
```

**2. within()** : Matches all methods within a specific class or package.

```java
within(package-name)
```

e.g.

```java
within(com.example.service.*)
```

**3. this() / target()**: Matches based on the type of proxy (\*(**this**) or target object (**target**)

```java
this(Type) or target(Type)
```

e.g.

```java
this(com.example.service.MyService)
```

**4. args()**": Matches methods based on the types of runtime arguments.

```java
args(argument-type-pattern)
```

e.g.

```java
args(java.lang.String, ..)
```

**5. @annotation()**: Matches methods annotated with a specific annotation.

```java
@annotation(annotation-type)
```

```java
@annotation(com.example.MyCustomAnnotation)
```

## 7. Compare different types of advices in Spring AOP

### Comparison of Different Types of Advices in Spring AOP

| Advice Type         | Description                                                                | When It Runs                                 | Example                                                       |
| ------------------- | -------------------------------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------- |
| **Before Advice**   | Executed before the target method is invoked.                              | Before the method execution.                 | `@Before("execution(* com.example.service.*.*(..))")`         |
| **After Returning** | Executed after the target method successfully completes without exception. | After the method returns successfully.       | `@AfterReturning("execution(* com.example.service.*.*(..))")` |
| **After Throwing**  | Executed if the target method throws an exception.                         | When an exception is thrown by the method.   | `@AfterThrowing("execution(* com.example.service.*.*(..))")`  |
| **After (Finally)** | Executed after the target method completes (whether successful or not).    | After method execution (success or failure). | `@After("execution(* com.example.service.*.*(..))")`          |
| **Around Advice**   | Surrounds the method and can control if and when it executes.              | Before and after method execution.           | `@Around("execution(* com.example.service.*.*(..))")`         |

## 8. On top of your Spring application which you did in Assignment #11

Refer the Coding folder
