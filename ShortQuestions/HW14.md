# HW14

Yuhang Li

## 1. Explain and compare following concepts, provide specific examples when doing comparison: 

### Testing related:

1. Unit Testing
2. Functional Testing
3. Integration Testing
4. Regression Testing
5. Smoke Testing
6. Performance Testing
7. A/B Testing
8. User Acceptance Testing

Here's a breakdown of the various types of testing in software development:

### 1. **Unit Testing**
- **Definition**: Unit testing focuses on testing individual components (usually methods or functions) of a system in isolation to ensure they perform as expected.
- **Example**: Testing the `addComment()` method in `CommentServiceImpl` to verify that it properly adds a comment.
- **Comparison**: It's the most granular type of testing, aiming to catch bugs at the lowest level. Compared to other types of testing, unit tests are fast to execute since they test small code units and don't require external dependencies like databases or networks.

### 2. **Functional Testing**
- **Definition**: Functional testing ensures that the application behaves as expected, focusing on specific functions or features of the system based on business requirements.
- **Example**: Testing if users can submit a form on a web page and receive the expected confirmation.
- **Comparison**: While unit testing focuses on small code units, functional testing validates a feature in the context of the whole application. It usually happens after unit testing and involves interaction with the application’s user interface.

### 3. **Integration Testing**
- **Definition**: Integration testing verifies the interactions between different modules or services of the application to ensure they work together properly.
- **Example**: Testing whether `CommentService` correctly interacts with `UserService` and `NotificationService` to notify users when a comment is added.
- **Comparison**: While unit tests test isolated pieces of code, integration tests check how those units work together. It’s a mid-level testing that can involve databases, file systems, or third-party services.

### 4. **Regression Testing**
- **Definition**: Regression testing ensures that new changes or additions to the codebase don’t break existing functionality.
- **Example**: After updating the comment feature, running previous tests to ensure the new feature doesn’t interfere with existing functionalities like editing or deleting comments.
- **Comparison**: Regression testing involves re-running existing tests after changes are made, whereas unit, functional, and integration tests are focused on specific aspects of the code.

### 5. **Smoke Testing**
- **Definition**: Smoke testing is a preliminary test to check the basic functionality of an application to determine whether it’s stable enough for further testing.
- **Example**: After deploying a new version of the app, running a smoke test to ensure users can log in, load the homepage, and access core functionalities.
- **Comparison**: Smoke tests are often referred to as "build verification" tests and are much more basic compared to functional or integration tests. It’s like a "quick check" to ensure everything is fundamentally working.

### 6. **Performance Testing**
- **Definition**: Performance testing evaluates how the application performs under specific conditions, such as load, stress, and scalability.
- **Example**: Testing how many concurrent users the application can handle without crashing.
- **Comparison**: Unlike other types of testing that focus on correctness or integration, performance testing focuses on speed, responsiveness, and resource usage.

### 7. **A/B Testing**
- **Definition**: A/B testing compares two versions of a web page, feature, or application to see which one performs better with real users.
- **Example**: Displaying two versions of a homepage (one with a large sign-up button and another with a small one) to determine which one generates more user sign-ups.
- **Comparison**: Unlike other testing methods, A/B testing is more user-focused and involves experimentation to optimize user experience, rather than verifying correctness.

### 8. **User Acceptance Testing (UAT)**
- **Definition**: UAT involves testing the system by end-users to ensure it meets the business requirements and works as expected in real-world scenarios.
- **Example**: Before releasing a new commenting feature, asking a group of users to try it out to ensure it meets their expectations and is intuitive.
- **Comparison**: UAT is often the last phase of testing before going live, where real users test the application. It's higher-level than unit or functional testing, as it focuses on business goals rather than specific technical functions.

### Summary Comparison:
- **Granularity**: Unit testing is the most granular, focusing on individual methods. Integration testing checks how different modules interact, while UAT and functional testing focus on entire workflows.
- **Timing**: Unit and integration tests happen earlier in development. Smoke testing is a quick check before detailed testing. Regression tests happen after changes are made, and UAT is near the end of the testing cycle.
- **Goal**: Functional, regression, and smoke testing ensure correctness. Performance testing checks speed and efficiency, while A/B testing optimizes for user engagement.



### Environment related:

1. Development
2. QA(QualityAssurance) 
3. 3. Pre-prod/Staging
4. Production

Here's a comparison of the different software environments:

### 1. **Development Environment**
- **Definition**: The development environment is where developers write, test, and debug code. It’s the first environment where new features, bug fixes, or other changes are made.
- **Purpose**: Developers use this environment to work on new functionality or fix issues without affecting other team members or end users.
- **Example**: A developer working on a new login feature on their local machine.
- **Comparison**: This environment is typically isolated from production and doesn't require the same level of stability or performance as other environments. It’s more flexible and may not have strict testing processes like the QA environment.

### 2. **QA (Quality Assurance) Environment**
- **Definition**: The QA environment is used by testers to validate the code before it moves to staging or production. This environment is where functional testing, integration testing, regression testing, and other test types take place.
- **Purpose**: To verify that new code behaves as expected and doesn’t break existing functionality. It often mirrors production but can include additional tools for testing and debugging.
- **Example**: A QA team running automated test scripts to verify a new user registration feature.
- **Comparison**: QA is typically more controlled than the development environment. The code here is more stable since it has already passed the initial development phase, but it’s still subject to many tests and debugging activities.

### 3. **Pre-prod/Staging Environment**
- **Definition**: The staging or pre-production environment is a nearly identical replica of the production environment. It is the last environment where testing is performed before the code is deployed to production.
- **Purpose**: To perform final checks in a production-like environment. This environment is used for UAT (User Acceptance Testing), performance testing, and smoke testing.
- **Example**: Deploying the entire system to staging for end-users or business stakeholders to test out the latest features before they go live.
- **Comparison**: The staging environment closely resembles the production environment in terms of setup, configurations, and data. It is considered stable and serves as the final step before deploying to production, unlike development and QA, which may have differences.

### 4. **Production Environment**
- **Definition**: The production environment is where the live application runs and is accessed by end users. This environment contains real data and handles actual business operations.
- **Purpose**: To provide the final, stable version of the software to customers and end-users.
- **Example**: A live e-commerce website used by thousands of customers.
- **Comparison**: The production environment is the most stable and closely monitored. Unlike development, QA, or staging, any issues here directly impact the end users, so changes to production are done with extreme caution. There is little to no debugging allowed, and any issue has immediate consequences.

### Summary Comparison:
- **Development**: Flexible, for code creation and testing by developers.
- **QA**: For rigorous testing, validating the code's correctness before moving to staging.
- **Pre-prod/Staging**: Mirrors production closely for final validation, including UAT and performance testing.
- **Production**: Live environment for end-users, highly stable, and contains real data.

## 2. Write unit test using **Junit** and **PowerMock** for following code (a static http client method which calls an external public API):

### You can call any public API (such as github public api: https://api.github.com/users/{UserId}/repos?page=1) In your unit test code, make sure you mock and stub everything properly, do NOT make real call to the API!



To create a unit test using JUnit and PowerMock for the static method `getHttpResponse()` in the `HttpClientService` class, we need to mock the static method, the external API call, and handle dependencies like `HttpURLConnection`.

### Steps:
1. **Use PowerMock**: This allows you to mock static methods.
2. **Mock Dependencies**: We'll mock the `HttpURLConnection`, `BufferedReader`, and any other external dependencies.
3. **Avoid Real API Call**: We will stub the external API responses to avoid making actual HTTP requests.

### Dependencies:
You'll need the following dependencies in your `pom.xml` for Maven:

```xml
<dependencies>
    <dependency>
        <groupId>org.powermock</groupId>
        <artifactId>powermock-module-junit4</artifactId>
        <version>2.0.9</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.powermock</groupId>
        <artifactId>powermock-api-mockito2</artifactId>
        <version>2.0.9</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.powermock</groupId>
        <artifactId>powermock-module-junit4-rule</artifactId>
        <version>2.0.9</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>3.7.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### Example Unit Test Code:

```java
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.InjectMocks;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;

@RunWith(PowerMockRunner.class)
@PrepareForTest({HttpClientService.class, URL.class})
public class HttpClientServiceTest {

    @Mock
    HttpURLConnection mockConnection;

    @Mock
    BufferedReader mockBufferedReader;

    @Before
    public void setUp() throws Exception {
        // Mock the static URL class
        PowerMockito.mockStatic(URL.class);

        // Mocking the connection
        URL mockUrl = PowerMockito.mock(URL.class);
        when(mockUrl.openConnection()).thenReturn(mockConnection);

        // Simulate the BufferedReader reading API response
        when(mockBufferedReader.readLine()).thenReturn("{\"key\":\"value\"}", (String) null);
        when(mockConnection.getInputStream()).thenReturn(new java.io.ByteArrayInputStream("{\"key\":\"value\"}".getBytes()));
    }

    @Test
    public void testGetHttpResponse() throws Exception {
        // Arrange: Setup static method mocking for URL and HttpURLConnection
        String baseUrl = "https://api.github.com";
        String path = "/users/testUser/repos?page=1";
        Map<String, String> headers = mock(Map.class);
        int connectTimeout = 5000;
        int readTimeout = 5000;

        // Act: Call the static method and verify results
        ObjectMapper objectMapper = mock(ObjectMapper.class);
        when(objectMapper.readTree(anyString())).thenReturn(null);  // Simulate the JSON response parsing

        // Call the method under test
        PowerMockito.mockStatic(HttpClientService.class);
        PowerMockito.when(HttpClientService.getHttpResponse(baseUrl, path, headers, connectTimeout, readTimeout))
                .thenReturn(null);  // Mock the actual response

        // Assert: Verify expected behavior
        assertNull(HttpClientService.getHttpResponse(baseUrl, path, headers, connectTimeout, readTimeout));
        
        verify(mockConnection).setRequestMethod("GET"); // Verify that GET was set on connection
        verify(mockConnection).setConnectTimeout(connectTimeout); // Verify timeout
        verify(mockConnection).disconnect(); // Verify disconnection
    }
}
```

### Key Elements:
- **PowerMockito.mockStatic()**: Used to mock static methods.
- **HttpURLConnection and BufferedReader Mocks**: Mocked the behavior of the external HTTP connection and the input stream.
- **No Real API Call**: We're returning a mocked JSON response (`{"key": "value"}`) to simulate an API call.

This unit test stubs and mocks everything, ensuring the test doesn't make real HTTP calls while verifying the behavior of the `getHttpResponse` method.
