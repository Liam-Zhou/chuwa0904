# HW10

Yuhang Li

## 1. List all of the annotations you learned from this class session.

Please refer as annotations.md

## 2. Explain tight coupling vs loose coupling and what does Spring IOC do?

**Tight coupling** refers to a scenario where the components in a system are highly dependent on one another. Changes in one component often require changes in the others. This makes the system harder to maintain, test, or extend because of the interconnected nature of the components. For example, if one class creates or directly manages the dependencies of another class, they are tightly coupled.

**Loose coupling**, on the other hand, means that components are minimally dependent on one another. The interaction between them is done through well-defined interfaces or abstractions, which makes changes in one component less likely to affect others. Loose coupling leads to a more flexible and maintainable system since each component can evolve independently.

### Spring IoC (Inversion of Control)

Spring IoC (Inversion of Control) is a design principle that helps achieve **loose coupling** in applications. Instead of components creating their dependencies, Spring’s IoC container manages object creation and their dependencies (also known as **dependency injection**). Spring IoC decouples the configuration and dependency management from the application logic, thus making the components more modular and easier to test or modify.

In simple terms, Spring IoC shifts the control of dependency management from the objects themselves to the Spring framework.

## 3. What is MVC pattern?

The **MVC pattern** (Model-View-Controller) is a software architectural pattern used for building user interfaces by separating an application into three interconnected components:

1. **Model**: The Model represents the data and business logic of the application. It directly manages the data, logic, and rules of the application. The Model also notifies the View when there's a change in the data, so the View can update itself.

2. **View**: The View is responsible for displaying the data provided by the Model in a specific format. It is the user interface that the user interacts with, but it doesn't contain logic beyond how the data is presented. The View listens to changes from the Model and updates the UI accordingly.

3. **Controller**: The Controller acts as an intermediary between the View and the Model. It handles user input and interacts with the Model to process the data. The Controller then updates the View based on the Model’s state. Essentially, it translates user actions into operations that update the Model.

### How MVC works:
- **User** interacts with the **View** (UI).
- **Controller** processes user input and updates the **Model**.
- **Model** changes state and notifies the **View**.
- **View** updates and reflects changes in the UI.

This separation of concerns makes the application more modular, maintainable, and testable. Spring MVC, for instance, implements this pattern to build web applications.

## 4. What is Front-Controller?

The **Front Controller** is a design pattern used in web applications where a single controller handles all incoming client requests and routes them to the appropriate handlers or actions. Instead of having multiple controllers handling specific types of requests, the front controller serves as a centralized entry point for managing all client interactions.

### Key Characteristics of the Front Controller Pattern:
1. **Centralized Control**: All incoming requests are first sent to the front controller, which is responsible for dispatching them to the appropriate handlers or services. This centralization improves manageability and consistency.
  
2. **Request Dispatching**: The front controller determines what action or component should handle a particular request based on the request parameters (such as URL or HTTP method). This typically involves routing to different controllers or views.

3. **Common Services**: Since all requests pass through the front controller, it's an ideal place to implement common functionality such as security checks, logging, or authentication, ensuring these services are consistently applied across the application.

### Example in Spring MVC:
In Spring MVC, the **DispatcherServlet** acts as the **Front Controller**. It receives all HTTP requests and delegates them to the appropriate handlers (such as controllers, views, or services) based on the URL mapping. This streamlines request processing and centralizes control.

### Benefits:
- **Separation of Concerns**: By centralizing request handling, the front controller promotes a clear separation between request processing logic and the application logic.
- **Consistency**: Common behaviors (security, logging, etc.) can be applied consistently across all requests.
- **Flexibility**: The front controller makes it easier to introduce new functionalities (e.g., caching or redirection) without modifying each controller separately.

## 5. Explain DispatcherServlet and how it works.

In Spring MVC, the **DispatcherServlet** is the central component that acts as the **Front Controller**. It handles all incoming HTTP requests and delegates them to the appropriate handlers, views, or other components within the framework. It plays a key role in routing requests, processing them, and generating responses.

### How DispatcherServlet Works:

1. **Client Request**: The client (browser or other clients) sends an HTTP request to the web application.

2. **Request Interception**: The **DispatcherServlet** intercepts the incoming request. It is configured in the web application's deployment descriptor (`web.xml`) or via annotations in modern Spring applications. All requests that match the mapping pattern (usually `/`) are sent to the DispatcherServlet.

3. **Handler Mapping**: The DispatcherServlet consults the **Handler Mapping** to determine which controller or handler should process the request. The handler mappings are defined using annotations (`@RequestMapping`) or XML configuration. The appropriate controller (also called a **handler**) is selected based on the request URL and method (GET, POST, etc.).

4. **Controller Execution**: Once the appropriate handler/controller is determined, the DispatcherServlet calls the associated controller method to handle the request. The controller processes the request (e.g., interacting with the model or database) and prepares data for the view.

5. **Model and View**: After processing, the controller returns a **ModelAndView** object to the DispatcherServlet, which contains both the data (model) and the logical view name that should be rendered (view).

6. **View Resolver**: The DispatcherServlet uses a **View Resolver** to resolve the logical view name into the actual view (e.g., a JSP, Thymeleaf, or HTML page). The View Resolver locates the correct template or view file.

7. **View Rendering**: The resolved view is rendered (i.e., the view template is populated with the model data) and the generated HTML is sent back as the response to the client.

8. **Response**: The rendered view is sent back to the client as the HTTP response, completing the request-response cycle.

### DispatcherServlet Workflow Diagram:
1. Client request → 2. DispatcherServlet → 3. Handler Mapping → 4. Controller → 5. ModelAndView → 6. View Resolver → 7. View → 8. Response

### Key Components Used by DispatcherServlet:
- **Handler Mapping**: Maps URLs to the appropriate controller (handler).
- **Controller**: Processes the request and returns the ModelAndView.
- **View Resolver**: Resolves the logical view name to an actual view file (JSP, Thymeleaf, etc.).
- **View**: Renders the model data into HTML or other formats.

In summary, the **DispatcherServlet** serves as the backbone of the Spring MVC architecture, acting as a **front controller** that orchestrates request handling, delegating tasks to different components in the framework for efficient processing and response generation.

## 6. What is JSP and What is Model And View?

### JSP (JavaServer Pages):
**JSP (JavaServer Pages)** is a server-side technology used to create dynamic web content, typically in the form of HTML, XML, or other types of files. JSP allows developers to embed Java code directly into HTML pages, enabling the creation of dynamic content that can respond to user inputs or interactions.

#### Key Features of JSP:
- **Dynamic Content**: JSP pages can generate dynamic content by embedding Java code that can access server-side resources like databases, APIs, and more.
- **Separation of Concerns**: JSP separates the presentation layer (HTML) from the business logic (Java code), though it still allows embedding Java code using special tags.
- **Tag Libraries**: JSP supports custom tags and tag libraries (like JSTL) that allow reusable logic to be embedded without directly using Java code, encouraging a cleaner separation of logic and presentation.
- **Lifecycle**: JSP is compiled into a servlet by the server, and then executed, making it an efficient way to serve dynamic content. The JSP lifecycle is similar to servlets (initialization, execution, and cleanup).

#### Example of JSP Code:
```jsp
<html>
<body>
    <h1>Welcome, <%= request.getParameter("user") %>!</h1>
</body>
</html>
```
In this example, Java code `<%= request.getParameter("user") %>` is embedded in the HTML to dynamically display the user's name.

### ModelAndView:
**ModelAndView** is a class in Spring MVC used to represent both the data (model) and the view to be rendered in a single object.

#### Components of ModelAndView:
1. **Model**: The **model** contains the data that you want to display in the view. This data is typically retrieved from a database or some other data source and is represented as key-value pairs (in the form of a `Map`). The model is sent to the view for rendering.
   
2. **View**: The **view** refers to the presentation layer (like JSP, Thymeleaf, or another template engine) that will render the data to be displayed to the user. It is specified by a logical view name (e.g., "homePage"), and the actual rendering is determined by the **View Resolver** in Spring.

#### Example of ModelAndView:
```java
@Controller
public class HomeController {

    @RequestMapping("/home")
    public ModelAndView showHomePage() {
        ModelAndView mav = new ModelAndView("homePage"); // 'homePage' is the logical view name
        mav.addObject("message", "Welcome to the home page!");
        return mav;
    }
}
```
- In this example, a `ModelAndView` object is created with the logical view name `homePage`.
- The `addObject` method adds a message to the model, which will be available in the view (e.g., JSP).
- The view (`homePage.jsp`) will use the data (model) to render the content.

### Relationship Between Model and View:
- **Model** holds the data that needs to be rendered (like a list of products, a user profile, etc.).
- **View** is the UI component that takes the model data and presents it in a user-friendly format (HTML, JSON, etc.).
- The **ModelAndView** class combines these two, specifying what data should be rendered (`model`) and which view should present that data (`view`).

## 7. Explain servlet and servlet container , name some servlet implementations and servlet containers other than tomcat

### Servlet:
A **Servlet** is a Java class that is used to handle HTTP requests and generate dynamic web content (like HTML, JSON, etc.) on the server side. Servlets run within a **Servlet Container** and respond to web client requests by interacting with backend resources (e.g., databases, APIs).

#### Servlet Lifecycle:
1. **Initialization**: The servlet is instantiated and initialized via the `init()` method when it is first loaded.
2. **Request Handling**: The `service()` method is called to handle each incoming request, which is then routed to either `doGet()`, `doPost()`, or other HTTP-specific methods based on the request type.
3. **Destruction**: The servlet is destroyed and the `destroy()` method is invoked when the servlet is taken out of service, allowing it to release any resources.

### Servlet Container:
A **Servlet Container** (or **Web Container**) is a part of a web server or application server that manages the lifecycle and execution of servlets. It provides the environment in which servlets run, handling low-level operations such as:
- **Managing the Servlet Lifecycle**: The container is responsible for instantiating, initializing, executing, and destroying servlets.
- **Request Handling**: It manages the HTTP requests and responses between clients and servlets.
- **Thread Management**: It ensures that requests are processed concurrently by managing thread pools.
- **Security and Configuration**: The container applies security constraints and servlet configurations defined in `web.xml` or annotations.

### Common Features of Servlet Containers:
- **Request routing**: Routes HTTP requests to the appropriate servlets based on the URL patterns.
- **Session management**: Handles session tracking using cookies or URL rewriting.
- **Concurrency**: Manages concurrent access and request handling for multiple users.
  
### Some Popular Servlet Implementations:
1. **Apache Tomcat**: One of the most widely used servlet containers that also implements the Java Servlet, JSP, and WebSocket specifications.
2. **Jetty**: A lightweight servlet container used in many embedded environments and small applications.
3. **GlassFish**: A full Java EE (Jakarta EE) application server that provides support for servlets, JSPs, and other Java EE technologies.
4. **JBoss (WildFly)**: A full Java EE application server that supports servlets, JSP, EJBs, and other enterprise technologies.
5. **Resin**: Another servlet and application server that provides high performance and scalability.

### Servlet Containers Other than Tomcat:
1. **Jetty**:
   - Lightweight and highly embeddable servlet container.
   - Commonly used in frameworks like Spring Boot for embedded applications.
   - Known for its scalability and performance.

2. **GlassFish**:
   - A complete Java EE (Jakarta EE) server with support for servlets, JSP, JSF, EJB, and more.
   - Often used for enterprise-grade applications that require full Java EE capabilities.

3. **JBoss (WildFly)**:
   - Full-featured Java EE application server that includes servlet and JSP support.
   - Ideal for building and deploying large, distributed enterprise applications.

4. **Resin**:
   - Provides high-performance and scalability.
   - Often used in large-scale Java applications with a focus on speed and reliability.

5. **WebLogic**:
   - An Oracle Java EE application server that includes robust support for servlets, JSP, and other enterprise-level features.
   - Commonly used in large-scale, mission-critical enterprise applications.

6. **WebSphere**:
   - An IBM Java EE application server that supports servlets, JSP, and EJB.
   - Known for its use in enterprise applications with high demands for reliability, security, and scalability.

Each of these containers provides the necessary infrastructure for running servlets, while some, like GlassFish, WildFly, and WebLogic, extend support for full enterprise Java specifications.



## 8

Please refer to the Coding directory

