# HW12 SpringAOP

## 2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions

## 3. What is the Aspect Oriented Programming, explain it with detailed use cases?

### Aspect Oriented Programming (AOP)

**Definition:**  
AOP is a programming paradigm that separates cross-cutting concerns (e.g., logging, security) from business logic, enhancing modularity.

**Key Concepts:**
- **Aspect:** Module containing cross-cutting concerns.
- **Advice:** Code executed at specific join points (e.g., before, after methods).
- **Pointcut:** Expression defining where advice should apply.
- **Join Point:** Specific points in program flow (e.g., method execution).

### Use Cases

1. **Logging:**
    - Use `@Before` advice to log method entry and `@After` advice for exit.
   ```java
   @Aspect
   public class LoggingAspect {
       @Before("execution(* com.example.service.*.*(..))")
       public void logBefore(JoinPoint joinPoint) {
           System.out.println("Entering: " + joinPoint.getSignature().getName());
       }
   }
   ```
   
2. **Transaction Management:**
    - Use `@Around` advice to handle transaction boundaries.
   ```java
   @Aspect
   public class TransactionAspect {
      @Around("execution(* com.example.service.*.*(..))")
      public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
         startTransaction();
         Object result = joinPoint.proceed();
         commitTransaction();
         return result;
      }
   }
   ```

3. **Security Check:**
   - Use `@Before` advice to enforce permission checks.
   ```java
   @Aspect
   public class SecurityAspect {
      @Before("execution(* com.example.service.SensitiveService.*(..))")
      public void checkPermission(JoinPoint joinPoint) {
         if (!userHasPermission()) {
         throw new SecurityException("Unauthorized");
         }
      }
   }
   ```
   - Benefits: Reduced code duplication, enhanced modularity, and easier maintenance

## 4.What are the advantages and disadvantages of Spring AOP?

### Advantages of Spring AOP
1. **Modularity:**  
   Separates cross-cutting concerns (e.g., logging, security) from business logic, leading to cleaner code.
2. **Reduced Code Duplication:**  
   Centralizes repetitive code (e.g., transaction management), making the application easier to maintain.
3. **Easy Integration:**  
   Integrates seamlessly with Spring components like `@Transactional` and `@Cacheable`.
4. **Declarative Configuration:**  
   Offers annotation-based configuration (`@Aspect`) and XML-based options, reducing boilerplate.
5. **Runtime Weaving:**  
   Dynamically applies aspects at runtime without modifying the source code.

### Disadvantages of Spring AOP
1. **Performance Overhead:**  
   Runtime weaving and proxy creation can lead to slight performance degradation.
2. **Complex Debugging:**  
   Tracing errors within aspects can be difficult due to indirect method execution.
3. **Limited Scope:**  
   Only supports method-level weaving, not field or constructor-level, unlike other AOP frameworks (e.g., AspectJ).
4. **Learning Curve:**  
   Understanding AOP concepts like pointcuts, join points, and advice can be challenging for beginners.

## 5. Explain following concept in your own words, you may include code snippet as part of your answer.
   1. Aspect
   2. PointCut
   3. JoinPoint
   4. Advice

### 1. Aspect
An **Aspect** is a modular unit of cross-cutting concerns like logging or security. It encapsulates multiple advices and pointcuts that define when and where the behavior should be applied.

```java
@Aspect
public class LoggingAspect {
    // Advice associated with a PointCut
    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethod(JoinPoint joinPoint) {
        System.out.println("Entering: " + joinPoint.getSignature().getName());
    }
}
```

### 2. PointCut
A **PointCut** is an expression that selects join points (specific points in program execution) where advices should be applied.

```java
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceLayerMethods() {}  // Selects all methods in service package
```

### 3. JoinPoint
A **JoinPoint** is a point in the execution of the program, such as method call or exception handling, where aspects can be applied. It provides contextual information (e.g., method name).

```java
@Before("execution(* com.example.service.*.*(..))")
public void logBeforeMethod(JoinPoint joinPoint) {
      System.out.println("Method called: " + joinPoint.getSignature().getName());
}
```

### 4. Advice
An **Advice** is the code that is executed at a specific join point, such as `@Befor`e`, `@After`, or `@Around`.
```java
@Around("execution(* com.example.service.*.*(..))")
public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.currentTimeMillis();
    Object result = joinPoint.proceed();  // Proceed to the target method
    long elapsedTime = System.currentTimeMillis() - start;
    System.out.println("Execution time: " + elapsedTime + " ms");
    return result;
}
```

## How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.

### Declaring a PointCut

Pointcuts can be declared directly in advice annotations or separately using the `@Pointcut` annotation with an empty method.

### Common PointCut Expressions

1. **`execution(...)`**  
   Matches method execution. Example: `execution(* com.example.service.*.*(..))`.

2. **`within(...)`**  
   Matches methods within a specific type or package. Example: `within(com.example.service..*)`.

3. **`args(...)`**  
   Matches methods with specific argument types. Example: `args(String, int)`.

4. **`bean(...)`**  
   Matches beans with specific names. Example: `bean(*Controller)`.

5. **`this(...)` / `target(...)`**  
   Matches a particular type. Example: `target(com.example.MyService)`.

6. **Logical Operators**  
   Combine expressions using `&&`, `||`, and `!`.

## Compare different types of advices in Spring AOP.

### Types of Advices in Spring AOP

1. **`@Before` Advice**
    - **Execution:** Runs before the target method.
    - **Use Case:** Logging or security checks before method execution.
    - **Limitation:** Cannot modify the return value.

2. **`@After` Advice**
    - **Execution:** Runs after the target method completes, regardless of the outcome (success or exception).
    - **Use Case:** Resource cleanup or final logging.
    - **Limitation:** Cannot access the returned value or exception.

3. **`@AfterReturning` Advice**
    - **Execution:** Runs after the target method returns successfully.
    - **Use Case:** Post-processing the returned value.
    - **Benefit:** Can access and modify the returned value.

4. **`@AfterThrowing` Advice**
    - **Execution:** Runs after the target method throws an exception.
    - **Use Case:** Logging exceptions or performing error handling.
    - **Benefit:** Can access the exception object for additional processing.

5. **`@Around` Advice**
    - **Execution:** Wraps around the target method, controlling its execution (before, after, or even skipping execution).
    - **Use Case:** Measuring execution time, transaction management, or modifying the input/output.
    - **Benefit:** Most powerful advice; can modify arguments, prevent method execution, or modify the return value.

### Comparison

| Advice Type      | Execution Time      | Access to Returned Value | Can Handle Exceptions | Control Over Method Execution |
|------------------|---------------------|-------------------------|----------------------|------------------------------|
| `@Before`        | Before Method       | No                      | No                   | No                           |
| `@After`         | After Method        | No                      | No                   | No                           |
| `@AfterReturning`| After Successful Return | Yes                 | No                   | No                           |
| `@AfterThrowing` | After Exception     | No                      | Yes                  | No                           |
| `@Around`        | Before & After      | Yes                     | Yes                  | Yes                          |


## 8. On top of your Spring application which you did in Assignment #11,
   1. Implement a customized logger using Spring AOP, your logger should be able to log your code and also external code.
   2. Your AOP logger should log method execution time, Rest API request details and response details.
   3. Your AOP logger should log with all possible joint points (before method execution, after method execution etc...)
   4. Your should bind jointPoints with your AOP code directly, instead of binding it with an empty method.
   5. Be ready to demo your implementation and prove it works in class.

[Customized logger](../Coding/hw11/q3/src/main/java/com/example/q3/aspect/LoggingAspect.java)

