## HW12
### Question 2
1. Setup:  JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach) for setup
   * @BeforeAll: set up expensive resources shared by all tests。
   * @BeforeEach：set up any conditions or initialize variables specific to the individual test case.
2. Test Execution：
   * @BeforeAll：Runs once before all test methods in the current class. It's typically used to set up expensive resources shared by all tests (e.g., starting a database or initializing a test server).
   * @BeforeEach: Runs before each individual test method. It is often used to set up any conditions or initialize variables specific to the individual test case.
   * @Test：The actual test method will annotated with @Test.
3. CleanUp
   * @AfterEach: Runs after each individual test method. It’s used to clean up resources or reset states that were set up in @BeforeEach. For example, closing a file or resetting a mock object.
   * @AfterAll: Runs once after all the tests in the current class are executed. It’s typically used to clean up shared resources created in @BeforeAll.

### Question 3
Parameterized testing in JUnit allows you to run the same test repeatedly with different sets of input data. They are supported through the @ParameterizedTest annotation.
JUnit provides several argument sources to supply input values for parameterized tests. Common ones include:
* @ValueSource: Provides an array of literals (e.g., ints, strings, etc.).
* @CsvSource: Allows you to provide comma-separated values.
* @CsvFileSource: Reads input from a CSV file.
* @MethodSource: Uses a method to supply arguments.
* @EnumSource: Supplies values from an enum type.

### Question 4
Mockito allows developers to create and configure mock objects to simulate the behavior of real objects in order to test specific parts of a system in isolation. Here is some features of Mockito:
* Mocking Objects: Mockito can mock interfaces and classes, so you can simulate their behavior in a test environment.
* Stubbing Methods: You can define how mocked methods should behave when called.
* Verifying Interactions: You can verify whether certain methods were called and with what arguments.
* Mockito supports argument matchers (e.g., any() or eq()) to check method calls with various input arguments.
* Spy: Instead of mocking an object entirely, you can create a "spy," which allows you to call the real methods of an object and stub only specific ones.

PowerMock is an extension to other mocking frameworks, such as Mockito, to provide additional features for cases that are otherwise hard to mock. 
* Mock Static Methods: Mockito cannot mock static methods by default, but PowerMock can.
* Mock Constructors: PowerMock allows you to mock the behavior of object constructors.
* Mock Private Methods: PowerMock can intercept private methods and change their behavior for testing purposes.
* Mock Final Classes and Methods: It can mock final classes and methods, which are usually problematic for standard mocking tools.

### Question 5 
@Mock: It is used to create mock objects for dependencies or other classes that you want to simulate during testing. 
@InjectMocks: It automatically inject the mocked dependencies (annotated with @Mock) into the class that you want to test.
Example code:
```
   @Mock
   private Service mockService; // Mocked dependency

   @InjectMocks
   private MyService myService; // Real object with dependency injected

   @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this); // Initializes mocks and injects them
    }

   @Test
   void testService() {
      when(dependencyService.getData()).thenReturn("Mocked Data");
        
      String result = myService.perform(); // Method of the real object
        
      assertEquals("Mocked Data Processed", result); // Assuming method appends "Processed"
      
   }
```
In this example:
* @Mock creates a mock of DependencyService.
* @InjectMocks creates an instance of **MyService** and automatically injects the mock **mockService** into it. The method **perform()** uses the mock, but the class under test (MyService) itself is not mocked.

### Question 6
Stubbing in unit testing refers to the process of defining the behavior of a mock object's method before it is called in the test. It isolates the class under test from external dependencies.
***Control over Dependencies**: Stubbing allows you to specify the output or behavior of a method, ensuring consistent results in tests, regardless of the actual implementation.
**Isolate the Class Under Test**: You focus on testing the logic of the class under test by stubbing external dependencies (e.g., services, databases, external APIs) without needing them to function or even exist.
**Flexible Behavior**: You can simulate different behaviors (e.g., exceptions, timeouts, or specific return values) to test edge cases or failure scenarios.
```
   MyDependency dependency = Mockito.mock(MyDependency.class);

   // Stub a method: When dependency.getData() is called, return "Mocked Data"
   when(dependency.getData()).thenReturn("Mocked Data");

   String result = dependency.getData();

   // Verify that the mock returns the stubbed data
   assertEquals("Mocked Data", result);   
```

### Question 7
Mockito ArgumentMatchers are a part of the Mockito framework that allows us to be flexible with the arguments passed to mocked methods.
Common Mockito ArgumentMatchers:
* **any()**: Matches any object, regardless of its type.
* **anyString()**: Matches any String.
* **anyInt()**: Matches any int.
* **eq(value)**: Matches exactly the value provided.
* **isNull()**: Matches when the argument is null.
* **notNull()**: Matches when the argument is not null.
* **contains(substring)**: Matches a String that contains the specified substring.
* **startsWith(prefix)**: Matches a String that starts with the specified prefix.

### Question 8
Hamcrest Matchers is a framework used for writing expressive and readable unit test assertions. It provides a set of matcher objects that allow you to define expectations for your test cases in a more flexible and human-readable way. 

* assertThat(actualValue, matcher): The primary method for making assertions using Hamcrest. It takes two arguments:
  * The actual value.
  * A matcher that defines the condition the actual value should satisfy

Matchers:
* **is()**: A simple matcher for equality. It is often used to assert that a value is equal to a specified value.
* **equalTo()**: Checks if two values are equal.
* **not()**: Negates the matcher inside it.
* **nullValue()** and **notNullValue()**: Check if a value is null or not null, respectively.
* **instanceOf()**: Verifies that a value is an instance of a specific class.
* **greaterThan()**, **lessThan()**, **greaterThanOrEqualTo()**, **lessThanOrEqualTo()**: Used to compare numeric values.
* **containsString()**: Checks if a string contains a specified substring.
* **startsWith()** and **endsWith()**: Check if a string starts or ends with a specific substring
* **hasItems()**: Used to check if a collection contains specific items.
* **hasSize()** and **hasLength()**: Assert that a collection or array has a specific size or length
* **allOf()**: Passes if all the specified matchers are satisfied (logical AND).
* **anyOf()**: Passes if any one of the matchers is satisfied (logical OR).

### Question 9
1. **@Mock** creates a fully mocked object that cannot call a real method, **@Spy** create a partially mocked object that can call a real method
2. **@Mock** does not call real methods unless explicitly instructed using when(). **@Spy** Calls real methods by default, unless methods are stubbed using doReturn() or when().
3. **@Mock** is used when we want to simulate the behavior of the object entirely. **@Spy** is used when we want to test real object behavior but selectively override some methods with mock behavior.

### Question 10
In the context of unit testing, an assertion is used to verify that the actual output of a piece of code matches the expected outcome. If the assertion fails (i.e., the condition is false), the test fails.
Common Assertion Methods:
1. **assertEquals()**: Verifies that two values are equal.
2. **assertNotEquals()**: Verifies that two values are not equal.
3. **assertTrue()**: Asserts that a condition is true. If the condition is false, the test will fail.
4. **assertFalse()**: Asserts that a condition is false. If the condition is true, the test will fail.
5. **assertNull()**: Asserts that an object is null.
6. **assertNotNull()**: Asserts that an object is not null.
7. **assertSame()**: Asserts that two references point to the same object (compares object references).
8. **assertNotSame()**: Asserts that two references do not point to the same object。
9. **assertArrayEquals()**: Asserts that two arrays are equal (compares array contents).
10. **assertThrows()**: Asserts that a piece of code throws a specific exception.
11. **fail()**: Explicitly fails a test. This can be useful for marking incomplete tests or adding a custom failure point.