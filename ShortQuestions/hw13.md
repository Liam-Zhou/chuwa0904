# HW13 -- unitTesting

## 2. What is the lifecircle of Junit?

1. **@BeforeAll**
- Runs once before all test methods in the class.

2. **@BeforeEach**
- Runs before each test method execution.

3. **@Test**
- Executes the actual test case.

4. **@AfterEach**
- Runs after each test method execution.

5. **@AfterAll**
- Runs once after all test methods in the class are completed.


## 3. Explain parameterized testing?

#### Parameterized Testing

##### Definition
Parameterized testing allows running a single test multiple times with different sets of inputs, enabling efficient testing of multiple scenarios using the same code.

##### Advantages
- Eliminates code duplication by using a single test method for various inputs.
- Enhances test coverage by verifying the behavior of different input combinations.
- Simplifies maintenance since adding or modifying test cases only requires updating the input parameters.

## 4. Explain `Mockito` and `PowerMock`.

### Mockito
- A popular Java testing framework used for creating and injecting mock objects.
- Simplifies unit testing by mocking dependencies and verifying interactions.
- Ideal for testing isolated components without external dependencies.

### PowerMock
- An extension of Mockito and other frameworks.
- Provides advanced mocking capabilities, such as mocking static methods, constructors, and private methods.
- Useful for testing legacy code and classes that Mockito alone cannot handle.

## 5. Compare @Mock and @InjectMock

### @Mock
- Creates a mock object of the class/interface.
- Used to simulate dependencies or external services.
- Does not inject the mock into the tested class.

### @InjectMocks
- Injects all available `@Mock` objects into the tested class.
- Useful for testing the class under test with its dependencies mocked.
- Automatically creates and initializes the class under test.

## 6. Explain stubbing.

### Definition
Stubbing is the process of defining pre-determined responses for method calls on mock objects. It allows tests to control the behavior of dependencies.

### Purpose
- Simulates return values or exceptions for specific inputs.
- Controls the flow of tests by replacing actual logic with predefined behaviors.

### Example Use Cases
- Returning specific values.
- Throwing exceptions.
- Simulating different scenarios.

## 7. what is Mockito ArgumentMatchers

### Mockito `ArgumentMatchers`

#### Definition
`ArgumentMatchers` is a class in Mockito that provides flexible matching rules for method arguments when creating mock behaviors.

#### Purpose
- Enables testing with variable or uncertain arguments.
- Allows for matching based on criteria such as types or custom conditions.

#### Common Methods
- `any()`: Matches any object of a specified type.
- `eq(value)`: Matches a specific value.
- `anyString()`, `anyInt()`, etc.: Matches any value of the specified primitive type.

## 8. what is Hamcrest Matchers

### Hamcrest Matchers

#### Definition
Hamcrest Matchers is a library for writing readable and flexible assertions in tests by defining match rules for expected values.

#### Purpose
- Enhances the readability of test assertions.
- Allows defining complex matching criteria for objects and values.

#### Common Matchers
- `is()`, `equalTo()`: Checks if values are equal.
- `hasItem()`, `contains()`: Verifies collections contain specific items.
- `greaterThan()`, `lessThan()`: Compares numeric values.

## 9. Compare @spy and @Mock?

### @Mock
- Creates a mock object with all methods returning default values (e.g., `null`, `0`).
- Behavior needs to be explicitly defined using stubbing.
- Ideal for completely mocking dependencies.

### @Spy
- Creates a partial mock, using real method calls unless stubbed.
- Allows tracking and verifying interactions on real objects.
- Useful when you need to test a class with some actual methods but want to mock specific behaviors.

## 10. Explain Assertion.

### Assertion

#### Definition
An assertion is a statement used in testing to verify that a specific condition holds true. If the condition fails, the test is marked as failed.

#### Purpose
- Validates expected outcomes against actual results.
- Helps identify bugs by ensuring code behaves as expected.

#### Common Assertions
- `assertEquals()`: Checks if two values are equal.
- `assertTrue()`, `assertFalse()`: Verifies boolean conditions.
- `assertNotNull()`: Ensures an object is not `null`.

## 11. Add unit tests for CommentServiceImpl under Redbook->branch 10_testing (fork or copy the project https://github.com/CTYue/springboot-redbook),
1. Enrich logics inside CommentServiceImpl methods, add if-else conditions in each methods.
2. In CommentServiceImpl, add following method, remove modelMapper dependency, and replace all modelMapper.map() with this method, write unit test for commentServiceMapperUtil
```java
public static CommentDto commentServiceMapperUtil(Comment comment) {
   ModelMapper modelMapper = new ModelMapper();
   return modelMapper.map(comment, CommentDto.class);
}
```
3. method coverage and branch coverage for CommentServiceImpl should be 100% (as much as you can), .






