## 1. List and Explain All the Newly Learned Annotations
- @Test: Marks a method as test case. It's standard annotation in Junit to define a unit test
```
@Test
void testMethod(){
}
```
- @BeforeEach: Runs before each test method is executed. Useful for setting up objects needed for the test cases.
```
@BeforeEach
void setup() {
}
```
- @AfterEach: Runs after each test method is executed. It's typically used for cleanup tasks after a test runs.
```
@AfterEach
void tearDown() {
}
```
- @BeforeAll: Executes once before all test methods in the class. it's commonly used for static setup tasks.
```
@BeforeAll
static void initAll() {
}
```

- @AfterAll: Runs once after all test methods in the clas have been executed. Useful for cleanup tasks like closing connections or releasing shared resources.
```
@AfterAll
static void tearDownAll() {
}

```

- @Mock: Creates a mock object for a class, allowing you to simulate behaviors without relying on actual implementations
```
@Mock
private SomeDependency dependency;

```

- @InjectMocks(Mockito): Injects mock dependencies into the class under test
```
@InjectMocks
private SomeService service;
```

- @Spy: Partially mocks an object, allowing you to use real method, but still override specific method with mocked behavior.
```
@InjectMocks
private SomeService service;

```
- @Captor: Captures arguments passed to mocked methods, allowing you to inspect the actual argument values
```
@Captor
ArgumentCaptor<String> stringCaptor;
```

- @ParameterizedTest: Marks a test as parameterized, allowing it to run multiple times with different input value;
```
@ParameterizedTest
@ValueSource(ints = {1, 2, 3})
void testWithParameters(int number) {
    assertTrue(number > 0);
}

```

- @ExtendWith: Used to extend test classes with additional functionality, often enabling additional testing features such as Mockito extension.
```
@ExtendWith(MockitoExtension.class)
```

- @Nested: Used to group tests logically by placing related test cases inside an inner class.
```
@Nested
class WhenConditionX {
    @Test
    void testX() {
        // Test logic for condition X
    }
}

```

- @DisplayName: Allows you to specify a custom name for test cases, making them more readable.
```
@DisplayName("Test method for checking user validation")
@Test
void userValidationTest() {
    // Test logic
}

```







## 2. What is the lifecycle of JUnit?
- liftcycle defines the flow of thow tests are executed in Junit.  Consisting of different phases, controlled by specific annotations
  - @BeforeALl: Runs once before all tests in the class. It is ued for one-time setup operations. such as opening databse connections. Must be static
  - @BeforeEach: Runs before each test method. it's used for initializing objects or setting the preconditions necessary for each test
  - @Test: Marks a method as a test case. This is where the actual test logic is placed. You can add assertions here to verify the expected behavior.
  - @AfterEach: Runs after each test method to clean up resources. It's commonly used for restting any stat modified during the test
  - @AfterAll: Runs once after all tests in the class. This is used for one-time cleanup. like closing databse connections or releasing shared resources. it must also be static.
```
public class ExampleTest{
    @BeforeAll
    static void SetUpBeforeClass(){
        System.out.println("Before All Tests");
    }
    @BeforeEach
    void setUp(){
        System.out.println("Before Each test");
    }
    
    @Test
    void testMethod1(){
        System.out.println("Test method 1");
        assertEquals(2, 1 + 1);
    }
    @AfterEach
    void tearDown(){
        System.out.println("After Each Test");
    }
    @AfterAll
    static void tearDownAfterClass(){
        System.out.println("After All Tests");
    }

}
```
- flow of execution:
  - @BeforeAll
  - @BeforeEach -> @Test -> @AfterEach
  - @BeforeEach -> @Test -> @AfterEach
  - @AfterAll


## 3. Explain Parameterized Testing
- Parameterized testing: allows you to run same test multiple times with different sets of inputs. It's particularly useful when you have to test the same logic with various data inputs. Instead of writing multiple test methods for each input. you can define a single test and supply it with different input data.
- @ValueSource: Provides literal values such as strings, ints, or enums.
```
@ParameterizedTest
@ValueSource(strings = {"Hello", "World"})
void testWithStringValues(String word){
    assertNotNull(word);
}
```
```
@ParameterizedTest
@CsvSource({'foo, 1", "bar, 2“, "'baz,quz', 3"})
void testWithCsvSrouce(String first, int second){
    assertNotNull(first);
    assertTrue(second > 0);
}
```
```
enum TimeUnit{Seconds, MINUTES, HOURS}
@ParameterizedTest
@EnumSource(TimeUnit.class)
void testWithEnum(TimeUnit unit){
    assertNotNull(unit);
}
```
```
static Stream<Arguments> provideArguments(){
    return Stream.of(
        Arguments.of("apple", 1),
        Arguments.of("banana", 2)
    };
}

@ParameterizedTest
@MethodSource("provideArguments")
void testWithCustomProvider(String, fruit, int rank){
    assertNotNull(fruit);
    assertTrue(rank > 0);
}
```

## 4. Explain Mockito and PowerMock
- Mockito  is popular mocking framework for unit tests in Java. it allows you to create mock object of classes and control their behavior during testing. Mockito can mock interfaces and classes, stubbing their methods, and verifying interactions.
  - Mocking: Create mock object
  - Stubbing: Define the behavior of mocked methods using when and thenReturn.
  - Verifying: Check whether a specific method was called on a mock.
```
@Mock
private SomeService service;

@Test 
void testService(){
    when(service.doSomething()).thenReturn("Mocked Result");
    assertQuals("Mocked Result", service.doSomething());
}
```
- PowerMock is an extensioon of Mockito that allows you to mock more challenging parts of the code:
  - Static Methods
  - Constructors
  - Final methods or classes
  - Private methods

```
@RunWith(PowerMockRunner.class)
@PrepareForTest(SomeClass.class)
public class SomeClassTest{
    @Test
    public void testStaticMethod(){
        PowerMOckito.mockStatic(SomeClass.class);
        when(SomeClass.staticMethod()).thenReturn("Mocked static Method"));
        
        String result = SomeClass.staticMethod():
        assertEquals("Mocked Static Method", result);
    }
    
}
```

## 5. Compare @Mock and @InjectMocks
- @Mock: This annotation is used to create a mock object of the class it is applied to. you can specify the behavior of this mock using when-thenReturn methods.
```
@Mock
private SomeDependency dependency;
```

- @InjectMocks: This annotation is used to inject mock objects into the class under test. it automatically initiallizes the class and injects any @Mock dependencies.
```
@InjectMocks
private SomeService service;

```

## 6. Explain Stubbing
- Stubbing: refers to defining the behavior of a mock object's method when it is called with specific inputs. This is particularly useful when testing a class that relies on external dependencies, like services or repositorires. don't want to involve in the actual test.
- using when-thenReturn. telling the mock object to return a certain value when a specific method is called with given parameters. This allows you to simulate different scenarios without actually calling the real implementation of the method.
    - Set up the mock object: use @Mock or Mockito.mock() to create a mock object.
    - Stub the method: when() to define what the mock object should return or do when a method is called
    - Call the method under test. The method in your class that relies on the stubbed mock will use the behavior you defined in when() clause.
    - verify: Optionally, use verify() to ensure that the method on the mock was called with the expected parameters.

```
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class UserServiceTest{
    @Mock
    private UserRepository userRepository;
    
    @Test
    void testFindUserById(){
        MockitoAnnotations.openMocks(this);
        UserService userService =  new UserService(userRepository);
        User mockUser = new User(1L, "John Doe");
        when (userRepository.findById(1L)).thenReturn(mockUser);
        User result = userService.findUserById(1L);
        assertEquals("John Doe", result.getName());
        verify(userRepository).findById(1L);

}
```
```
@Test
void testFundUserByIdThrowsException(){
    MockitoAnnotations.openMocks(this);
    UserService userSerivce = new UserService(userRepository);
    when(userRepository.findById(1L)).thenThrow(new RuntimeException("User not found"));
    
    assertThrows(RuntimeException.class, () -> {
        userService.findUserById(1L);
        
    });
}
```


## 7. What is Mockito ArgumentMatchers?
- Mockito argumentMatcher are used to specify flexible, parameterized stubs or verifications in tests. They allow to match arguments passed to mocked methods without needing to hard-code the exact values
- This is useful when you want to match calls to a mock method based on general conditions rather than specific values, which helps in making tests more maintainable and less brriitle
- any():Matches any object of any type
```
when(mockObject.someMethod(any())).thenReturn("value");
```
- any(Class<T> type): Matches any object of a specific type.
```
when(mockObject.someMethod(any(String.class))).thenReturn("value");
```

- eq(T value): Matches an exact value. Useful when combined with other argument matchers.
```
when(mockObject.someMethod(eq("John"))).thenReturn("Welcome John");
```

- isNull(): Matches null arguments
```
when(mockObject.someMethod(isNull))).thenThrow(new IllegalArgumentException());
```

- notNull(): Matches any non-null argument:
```
when(mockObject.someMethod(notNull())).thenReturn("Non-null value");
```

- anyInt(), anyString(), anyLong: Matches any integer, string, or long type, respectively
```
when(mockObject.someMethod(anyInt))).thenReturn("Integer passed");
```

- argThat(Matcher<T> matcher): allow for custom argument matching using a lambda expression or any custom matcher.
```
when(mockObject.someMethod(argThat(arg -> arg.startsWith("test")))).thenReturn("Starts with test");
```
```
public class UserService{
    private UserRepository userRepository;
    public UserService(UserRepository userRepository){
        this.userRepository = userRepository;
    }
    public User findUserByEmail(String email){
        return userRepository.findByEmail(email);
    }
}
public interface UserRepository{
    User findByEmail(String email);
}

import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class UserServiceTest{
    @Mock
    private UserRepository userRepository;
    
    @Test
    void testFindUserByAnyEmail(){
        MockitoAnnotations.openMocks(this);
        
        UserService userService = new UserService(userRepostory);
        User mockUser = new User(1L, "John Doe", "johndoe@example.com");
        when(userRepository.findByEmail(anyString())).thenReturn(mockUser);
        
        User result = userService.findUserByEmail("randomemail@example.com");
        assertEquals("John Doe", result.getName());
        verify(userRepository).findByEmail(anyString());
    }
}

}
```

## 8. What is Hamcrest Matchers?
- Hamcrest is framework used for writing readable assertions in unit tests. provides a set of matchers that can be used to assert conditions in a more expressive and flexible way than traditional assertions.
  - Hamcrest matchers allow for assertions that are more human-readable.
  - They enable you to combine multiple conditions in a single assertion
  - you can compose matchers to test more complex conditions.
- is() mathcer that asserts that the actual value is equal to the expected value. It acts as a wrapper around other matchers
  - assertThat(actual, is(expected));
- euqal(): Asserts that two values are equal.
  - assertThat("test", equalTo("test"));
- not(): Asserts that the actual value does not match the expected value.


## 9. Compare @Spy and @Mock
- @Mock
  - Purpose: Creates a full mock of a class or interface. The mock object has no real behavior by default—every method call on it returns a default value (null, 0, false, etc.) unless it is specifically stubbed.
  - Behavior: Methods on the mock object do not execute any real logic; instead, you can define their behavior explicitly using stubbing (e.g., when(mock.method()).thenReturn(value)).
  - Use Case: Use @Mock when you want to completely control the behavior of the dependency and you don’t care about calling the actual methods of the class.

- @Spy
  - Purpose: Creates a partial mock or a spy on a real object. A spy wraps an existing instance and allows you to call real methods on it, but you can also override specific methods with mock behavior.
  - Behavior: By default, the real methods of the spied object are called unless explicitly stubbed. This means you can selectively override behavior in specific methods while allowing the rest of the methods to execute normally.
  - Use Case: Use @Spy when you want to test real behavior but need to stub or mock certain methods.


# 10. Explain Assertion
- Assertion:
  - An assertion is a statement used in testing to check if a certain condition is true. Assertions are a fundamental part of unit testing because they allow you to verify that the expected outcome matches the actual outcome of your code. If an assertion fails, it means that the code did not behave as expected, and the test will fail._














