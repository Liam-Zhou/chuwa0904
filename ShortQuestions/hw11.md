
# Spring Security Homework

## 1. Annotations Learned from Class and Homework

See [annotations.md](annotations.md)

## 2. TLS, PKI, Certificate, Public Key, Private Key, and Signature

### TLS (Transport Layer Security)
TLS is a cryptographic protocol designed to provide secure communication over a computer network. It is the successor to SSL (Secure Sockets Layer). It ensures the confidentiality and integrity of data exchanged between two applications.

### PKI (Public Key Infrastructure)
PKI is a framework that manages the generation, distribution, and verification of digital certificates. It uses a system of public and private keys to enable secure data transmission.

### Certificate
A certificate is a digital document that contains a public key and the identity of the certificate holder. Certificates are issued by trusted Certificate Authorities (CA) and are used to verify the identity of the holder.

### Public Key
A public key is used to encrypt data or verify a signature. It is shared with anyone who needs to send encrypted data to the owner of the corresponding private key.

### Private Key
A private key is kept secret and is used to decrypt data encrypted with the public key or to create a digital signature.

### Signature
A signature is a cryptographic technique used to ensure the integrity and authenticity of a message or document. It is created by the sender using their private key and can be verified by anyone using the sender's public key.

## 3. HTTPS Spring Security Application with Self-Signed Certificate
1. Package a self-signed certificate in the form of a JKS file, as part of your application, name it properly.
2. Test if you can verify your HTTPS API without importing the self-signed certificate to your local certificate chain. If not, explain why.
3. Explain what did you do to make HTTPS call work, DO NOT bypass TLS/SSL verification in Postman (this is cheating)!
    Tutorial: https://www.baeldung.com/spring-channel-security-https

See the project in [Coding/HW10 Spring Security Project](../Coding/hw11/demo/)

Answer 2: I can't verify the HTTPS API without importing the self-signed certificate to my local certificate chain. Reasons:
1. Trust Anchors: HTTPS relies on a chain of trust. The browser or client (like curl or Postman) compares the certificate presented by the server against a set of trusted Certificate Authorities (CAs). If the certificate or its issuers are not in this trusted list, the connection is considered untrustworthy.
2. Self-Signed Certificates: A self-signed certificate means it is signed by the entity presenting the certificate rather than a trusted CA. Since self-signed certificates aren't issued by a recognized CA in the trust store of most clients, they aren’t trusted by default.
3. Security Mechanism: This mechanism prevents man-in-the-middle attacks. If self-signed certificates were trusted automatically, it would be trivial for malicious parties to spoof any HTTPS server.

Answer 3: To ensure that HTTPS calls work in Postman without bypassing TLS/SSL verification, I first generated a self-signed certificate using Java’s keytool. I then configured Spring Boot to use this certificate for SSL/TLS encryption. Next, to overcome the trust issue associated with self-signed certificates, I imported this certificate into both my operating system's trusted store and directly into Postman. In Postman, I added the certificate under the Certificates setting, specifying the localhost and port to associate it with the certificate. By importing the certificate into the trusted store of the OS and Postman, I ensured that the HTTPS requests were recognized as secure without any SSL warnings, thus maintaining a high level of security compliance without having to bypass SSL verification in Postman. This approach validates the SSL/TLS setup thoroughly, ensuring that the application behaves as expected in a secure manner.


## 4. HTTP Status Codes for Authentication and Authorization Failures

- 401 Unauthorized: The request requires user authentication.
- 403 Forbidden: The server understands the request but refuses to authorize it.
- 400 Bad Request: Issues with the request syntax, like malformed tokens.

## 5. Comparison of Authentication and Authorization

- **Authentication**: Verifies the identity of the user (e.g., login with credentials).
- **Authorization**: Determines what resources the user can access (e.g., role-based access).

Important components in Spring Security:
- `AuthenticationManager`: Manages authentication processes.
- `AuthenticationProvider`: Used by `AuthenticationManager` to authenticate users.
- `UserDetailsService`: Loads user-specific data.
- `AuthenticationFilter`: Filters incoming requests for authentication.

## 6. HTTP Session Explanation

An HTTP session is a server-side storage that retains the state of a user across multiple requests. A session ID is sent as a cookie to the client, which is used in subsequent requests to maintain the session.

## 7. Cookie Explanation

A cookie is a small piece of data stored on the client side. It is sent with each HTTP request and can be used for storing user preferences, session IDs, and other information necessary for web applications.

## 8. Comparison of Session and Cookie

- **Session**: Server-side, stores data for each user.
- **Cookie**: Client-side, used to store small amounts of data on the user's device.
  
## 9. Websites Supporting Google SSO and How SSO Works

- **GitHub**: Users can log in using their Google account. During login, GitHub redirects to Google's OAuth 2.0 server, where users grant permissions. After successful authentication, Google provides a token that GitHub uses for authorization.
  
- **Stack Overflow**: Uses a similar mechanism as GitHub. Stack Overflow redirects users to the Google login page, where authentication is performed. Once done, Google issues a token to access Stack Overflow.

The authentication flow can be traced in the Chrome Developer Tools by observing the OAuth 2.0 token exchange.

## 10. Session and Cookie Usage for User Information Across Applications

Sessions store user-specific data on the server, and a session ID is sent to the client as a cookie. Cookies, on the other hand, can store limited data like session IDs or preferences, allowing web applications to track users across requests.

## 11. Spring Security Filter

Spring Security filters intercept HTTP requests and perform security-related operations, such as authentication and authorization.

## 12. Bearer Token and JWT

A Bearer Token is a type of access token. JWT (JSON Web Token) is a compact token format used to represent claims. It consists of three parts: Header, Payload, and Signature.

## 13. Storing Sensitive Information in a Database

Passwords and credit card numbers should never be stored in plain text. Instead, passwords should be hashed using secure algorithms like bcrypt, and sensitive data should be encrypted.

## 14. Comparison of `UserDetailService`, `AuthenticationProvider`, `AuthenticationManager`, and `AuthenticationFilter`

- **UserDetailsService**: Loads user-specific data from a data source.
- **AuthenticationProvider**: Authenticates users based on provided credentials.
- **AuthenticationManager**: Manages the authentication process.
- **AuthenticationFilter**: Intercepts requests and delegates authentication.

## 15. Disadvantage of Session and How to Overcome It

One disadvantage of sessions is scalability. Since session data is stored on the server, it can lead to performance bottlenecks in a distributed environment. To overcome this, sessions can be shared across servers using technologies like Redis.

## 16. Accessing `application.properties` Values in Spring Security

In Spring Security, you can access values from `application.properties` using the `@Value` annotation:
```java
@Value("${property.name}")
private String propertyName;
```

## 17. Role of `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)`

- **`configure(HttpSecurity http)`**: Configures the security of HTTP requests, such as which requests need authentication or authorization.
- **`configure(AuthenticationManagerBuilder auth)`**: Configures authentication mechanisms, such as in-memory or JDBC-based authentication.

## 18. Additional Reading

For additional resources, refer to:
- [Spring Security Interview Questions](https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern)
