# HW12 Spring AOP

## 1. List all of the annotations you learned from this class session.

1. @ComponentScan(basePackages = { "com.chuwa.training" }):

- Scans the specified base package for Spring components (like @Controller, @Service, @Repository, etc.).

2. @PutMapping(value = "/{id}", produces = "application/xml", consumes = "application/json"):

- Handles HTTP PUT requests.
- The value attribute defines the URL pattern.
- The produces attribute specifies the media type (e.g., XML) that the method will produce in the response.
- The consumes attribute specifies the media type (e.g., JSON) that the method expects in the request body.

3. @RestController:

- A convenience annotation that combines @Controller and @ResponseBody.
- Used to simplify the creation of RESTful web services by returning the response directly as an object in the form of JSON or XML.

## 2. What is the lifecircle of JUnit

The lifecycle of a JUnit test, particularly in JUnit 5 (the latest version), involves the process and stages that JUnit follows when running a test class and its methods.

### JUnit Test Lifecycle

The lifecycle of JUnit tests involves the following phases:

- **BeforeAll (`@BeforeAll`)**:
  - Executes **once** before all tests in the class.
  - Must be a `static` method.
- **BeforeEach (`@BeforeEach`)**:
  - Runs **before each** individual test method.
- **Test (`@Test`)**:
  - The actual test methods, each representing a test case.
- **AfterEach (`@AfterEach`)**:
  - Runs **after each** test method.
- **AfterAll (`@AfterAll`)**:
  - Executes **once** after all tests in the class.
  - Must be a `static` method.

This structure allows setup and cleanup operations to be handled around the test methods.

## 3. Explain parameterized testing.

`Parameterized testing` in JUnit allows running the same test multiple times with different sets of input data. It enables you to define a test method that accepts parameters and then specify the data sets, ensuring that each test case is executed with different inputs. This helps in testing multiple scenarios without duplicating code. In JUnit 5, parameterized tests use the @ParameterizedTest annotation along with sources like `@ValueSource`, `@CsvSource`, `@MethodSource`, and more to provide the test data.

## 4. Explain Mockito and PowerMock

`Mockito` is a popular Java framework used for creating mock objects in unit tests. It allows you to simulate the behavior of complex dependencies, making it easier to isolate the class being tested. Mockito is widely used for its simple syntax and ability to verify interactions between objects without actually invoking real implementations.

`PowerMock` extends the capabilities of Mockito, enabling you to mock static methods, constructors, final classes, and private methodsâ€”features that Mockito cannot handle directly. It is particularly useful when dealing with legacy code or situations where altering the codebase is not possible, but it can be more complex and less preferred for new projects due to the complexity and potential for tighter coupling with implementation details.

## 5. Compare `@Mock` and `PowerMock`

`@Mock`: Creates a mock object of a class or interface. It is used when you want to simulate the behavior of a dependency without calling its actual implementation. Typically used in unit tests to mock dependencies.

`@InjectMocks`: Automatically injects the mocks created with @Mock into the object under test. It is used when you want to create an instance of the class you are testing and inject its dependencies as mocks. This helps in testing the class with all its dependencies mocked without manually setting them up.

In summary, `@Mock` is for creating mocks, while `@InjectMocks` is for injecting those mocks into the class being tested.

## 6. Explain `stubbing`

`Stubbing` is the process of defining the behavior of a mock object in unit tests. It allows you to specify what a mock should return when certain methods are called with specific arguments. This is useful for controlling the outputs of methods that interact with external systems or complex logic, allowing you to test only the functionality of the unit under test without relying on real implementations. In frameworks like Mockito, stubbing is done using methods like `when()` and `thenReturn()`.

## 7. What is Mockito ArgumentMatchers.

**_Mockito_** `ArgumentMatchers` are used to specify flexible criteria for matching arguments in method calls during mocking or verification. They allow you to define how mock objects should respond when methods are called with certain types or ranges of arguments, rather than exact values. Common `ArgumentMatchers` include `any()`, `eq()`, `anyString()`, and `anyInt()`. These help in creating more generalized stubbing or verification, making it easier to write tests where exact input values may vary.

## 8. What is `Hamcrest` Matchers

`Hamcrest Matchers` are a set of matchers used for writing more readable and expressive assertions in unit tests. They allow you to define expected conditions or patterns in an intuitive way. Hamcrest provides methods like `is()`, `equalTo()`, `containsString()`, `hasItems()`, and more, which can be used to check properties of objects or collections. It is commonly used with testing frameworks like JUnit to make assertions more descriptive and easier to understand.

## 9. Compare `@spy` and `@Mock`

`@Mock:` Creates a complete mock of a class or interface, meaning all methods are stubbed and return default values (like null or 0). You need to define specific behavior for methods if needed. It does not use any of the real method implementations.

`@Spy:` Creates a partial mock (spy) of a class, which means it uses the actual implementation of the class methods unless they are specifically stubbed. Spies are useful when you want to test some methods using real behavior while mocking others.

In summary, `@Mock` simulates the entire object, while `@Spy` allows real methods to be used along with stubbing specific behavior.

## 10. Explain Assertion

`Assertions` are statements used in testing to verify that a particular condition or expression is true. They help validate the expected outcomes of a test by comparing the actual result against the expected value. If the condition is true, the test continues; if false, the test fails, indicating an issue in the code. Assertions are commonly used in unit testing frameworks like JUnit (e.g., `assertEquals()`, `assertTrue()`, `assertNotNull()`), ensuring the code behaves as intended.
